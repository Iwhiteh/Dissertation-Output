---
title: "Dissertation"
author: "Imogen Whitehead"
output:
  html_document:
    number_sections: yes
    code_folding: hide
    theme: cerulean
    toc: yes
---

```{r setup, echo=TRUE, message=FALSE}
#message=FALSE means some output messages aren't printed in the knitted HTML document

knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE) 
#message=FALSE, echo=FALSE and warning=FALSE ensure any error messages aren't shown in the output HTML file

#message=FALSE means no output messages are printed on the knitted HMTL file
#loading any necessary packages
library(dplyr)
library(tidyverse) 
library(knitr)
library(readr)
library(ggplot2)
library(bbmle)
library(mizer) 
library(Hmisc)
library(lme4)
library(RColorBrewer)
library(viridis)
library(hexbin)
library(ggpattern) 
```

```{r loading, message=FALSE, echo=TRUE}
load("stomach_dataset.Rdata")
#loading the dataset to be used in analysis (the dataset is already named stom_df)

df <- stom_df %>% transmute(haul_id, ices_rectangle, year, pred_species, 
                            pred_weight_g, pred_length_cm, prey_weight_g, 
                            prey_type = prey_funcgrp, indiv_prey_weight = prey_ind_weight_g, 
                            prey_count, n_stomachs, no._prey_per_stmch = prey_count/n_stomachs, ppmr) 
#creating a new data set called 'df' which only contains certain selected columns

df <- df[df$indiv_prey_weight != 0, ]
df <- df[df$pred_weight_g != 0, ]
df <- df[df$indiv_prey_weight != Inf, ]
#Removes any points where the prey weight = Inf or 0, or the predator weight = 0
```

```{r cleaning smaller, message=FALSE, echo=TRUE}
renamed_df = df %>% 
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Micromesistius poutassou", "Blue Whiting")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Gadus morhua", "Cod")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Limanda limanda", "Common Dab")) %>%
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Merluccius merluccius", "European Hake")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Melanogrammus aeglefinus", "Haddock")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Clupea harengus", "Herring")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trachurus trachurus", "Horse Mackerel")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Scomber scombrus", "Mackerel")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lepidorhombus whiffiagonis", "Megrim")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lophius piscatorius", "Monkfish")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus esmarkii", "Norway Pout")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Pleuronectes platessa", "Plaice")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus minutus", "Poor Cod")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Solea solea", "Sole")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Sprattus sprattus", "Sprat")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Merlangius merlangus", "Whiting"))
#Renaming the predator species from their latin names (e.g. Capros apers) to their more common names (e.g. Boarfish)
#Creates a new data frame (called 'renamed_df') with these replaced names

species_list <- c("Blue Whiting", "Cod", "Common Dab", "European Hake", "Haddock", "Herring",
                     "Horse Mackerel", "Mackerel", "Megrim", "Monkfish", "Norway Pout",  "Plaice",
                     "Poor Cod", "Sole", "Sprat", "Whiting")
#Creates an array called 'species_list', which is list of the predator species we are focusing on in this project

renamed_df <- renamed_df[renamed_df$pred_species %in% species_list, ]
#Removes any observations of predator species not in the species_list, i.e. they are irrelevant data points for this project

renamed_df$lppmr <- log(renamed_df$ppmr)
renamed_df$lprey_weight <- log(renamed_df$indiv_prey_weight)
renamed_df$lpred_weight <- log(renamed_df$pred_weight_g)
#Adds columns which take the log value of ppmr, individual prey weight and predator weight to the main data set
```

# Introduction

This data set is formed from recordings taken by multiple ships between the years 1886-2016.

Fish were taken from some location, and their individual stomach contents recorded. Predators of the same species and (roughly) the same weight/size were recorded as a single data point (the number of predators for each data set is called 'n_stomachs'). Prey of (roughly) the same size found in these stomachs were recorded in this same data point, and the total number of prey in some data point is called 'prey_count'. For each individual data point,

$$
    \text{no. prey per stomach} = \frac{\text{no. of stomachs sampled}}{\text{total no. of prey}}
$$
This is an approximation of the number of prey per stomach for some specific predator, and is called '
no._prey_per_stmch'.

Using similar logic,'prey_weight_g' is the total weight of prey in the multiple stomachs sampled to make up one datapoint. 'indiv_prey_weight' is then the weight of one single prey individual found in the stomach


There are some other column names which are useful to note:

* ices_rectangle accounts for location of points, where each area the points are sampled in is split up into a number of smaller rectangles and each is given a unique name
* ppmr stands for 'predator prey mass ratio', and is calculated by:
* haul_id is a identification tag given to each individual ship which recorded observations

# Distribution of prey type eaten for each predator

```{r distribution of prey, echo=TRUE}
ggplot(renamed_df, aes(x=prey_type, fill=prey_type)) +
   geom_bar_pattern(stat = "count",
                    pattern_color = "white",
                    pattern_fill = "black",
                    aes(pattern = prey_type, pattern_angle = prey_type)) +
  facet_wrap(~renamed_df$pred_species, scale="free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribution of prey types for each predator species", x="Prey type",
       y="Number of Observations")
 
#geom_bar_pattern() creates a bar chart from the specified data, where each category has a different pattern used to fill it
#Using different patterns as well as different colours to fill the bars ensures the data can be understood if looked at in grey scale, and makes the document accessible for colour blind people
#facet_wrap() means an individual bar chart is created for each individual predator species
#'theme()' adjusts the labels along the x-axis so they lie slightly angled to the vertical direction so they are easy to read
#scale_fill_brewer changes the colour palette of the plot so that the colours are easy to distinguish between, and renames the title of the key to show which colour means what
```

These are individual bar charts showing the distribution of the type of prey each predator eats.

The prey types are:

* Benthos: organisms that live on/near the bottom of a body of water
* Fish: aquatic, craniate (have a skull), gill-bearing animals that lack limbs with digits (i.e. their limbs don't have toes or fingers)
* Nekton: the actively swimming aquatic organisms
* Other: misc. types that don't fit into the other categories
* Zooplankton: animal plankton (plankton are aquatic organisms that are unable to swim effectively against currents)

We can see that some predators eat a range of prey types (e.g. Whiting), while others prefer to eat a single prey type in abundance (e.g. European Hake and Monkfish mostly consume fish as their prey).

# Most common prey weights
```{r log(prey weight) v. number of prey per stomach, echo=TRUE}
ggplot(data = renamed_df, aes(lprey_weight, no._prey_per_stmch)) + 
      labs(title = "Number of prey per predator stomach v. log(prey weight) ", 
       x="log(prey weight)", y="Number of prey per predator stomach") + 
      geom_point(size=0.5)

#geom_point() adds individual points which show individual recorded points
#size=0.5 defines the size of each point on this graph
``` 

This graph is looking at the distribution of the weight of prey recorded, i.e. looking at what is the most common prey weight over all prey species. It is a graph over all the data points, so includes recordings from all the ships involved.

There are some potentially interesting results, so results from different ships were plotted on individual curves to further look into these results.

```{r sep by all ships, echo=TRUE, fig.height=12, fig.width=15}
renamed_df$haul_id_short <- gsub("\\-.*", "", renamed_df$haul_id)
renamed_df$haul_id_short <- gsub("_", "", renamed_df$haul_id_short)
#the haul_id values are renamed to be shortened versions of the ship names (e.g. CLYDE) rather than the complete id (e.g. CLYDE-1935-6)

ggplot (data = renamed_df, aes(x=lprey_weight, y=no._prey_per_stmch)) + 
  labs(title = "Number of prey per stomach v. log(prey weight) - separated by all ship names",
       x="log(prey weight)", y="Number of prey per stomach") + 
  geom_point(size=0.02, colour="red") +
  theme(strip.text = element_text(size = 5)) + 
  facet_wrap(~renamed_df$haul_id_short, scale="free_y") 
```

Taking a closer look at some of these ships gives the plots below:

```{r sep by ships, echo=TRUE}
interesting_haul <- filter(renamed_df, 
                           haul_id_short=='CLYDE'|haul_id_short=='END04'|haul_id_short=='LUC'|
                             haul_id_short=='HIDDINK'|haul_id_short=='EXCmacDATSTO815'|
                             haul_id_short=="Excmacdatsto815error")
#interesting_haul is a new data frame which only contains values recorded by ships which gave "interesting" looking datapoints

haul_list_interesting <- unique(interesting_haul$haul_id_short)
#creates an array containing every individual (renamed) ship name that we are interested in

ggplot (data = interesting_haul, aes(x=lprey_weight, y=no._prey_per_stmch)) + 
  labs(title = "Number of prey per stomach v. log(prey weight) 
       - separated by ship names, for a selection of 6 ships",
       x="log(prey weight)", y="Number of prey per stomach") + 
  geom_point(size=0.02, colour="red") +
  theme(strip.text = element_text(size = 10)) + 
  facet_wrap(~interesting_haul$haul_id_short, scale="free_y")
```

These six graphs show a range of unusual looking points:

1. $y \propto e^{-x}$ relation for END04 (i.e. no. per stomach is proportional to 1/prey weight)
2. lots of observations for single prey weights for LUC and CLYDE (554)
3. lots of the same no. of prey per stomach observations for HIDDINK.(27180)
4. the EXCmacDATSTO815 and Excmacdatsto815error seem to represent exactly the same data

There are a number of other ships which also provided potentially erroneous data, and the number of datapoints affected are as below:

```{r no of obs, echo=TRUE}
type1 <- length((filter(renamed_df, haul_id_short=='END04'))$haul_id_short)
#counting the number of observations recorded for each sort of error or interesting relation

type2 <- length((filter(renamed_df, haul_id_short=='CLION09' | haul_id_short=='LUC' | haul_id_short=='UNITY' | haul_id_short=='CLYDE'))$haul_id_short)

type3 <- length((filter(renamed_df, haul_id_short=='BEAVER'|haul_id_short=='BRUCELLA'|haul_id_short=='BULLEN'|haul_id_short=='CIROL04'|haul_id_short=='CIROL10'|haul_id_short=='CLION03'|haul_id_short=='CLION07'|haul_id_short=='CLION12'|haul_id_short=='COREL02'|haul_id_short=='COREL06'|haul_id_short=='CORY04'|haul_id_short=='CYPRIS'|haul_id_short=='END02'|haul_id_short=='END12'|haul_id_short=='HEINCKE147'|haul_id_short=='HIDDINK'|haul_id_short=='OITHONA'|haul_id_short=='STRANDLINE'|haul_id_short=='TELLINA'))$haul_id_short)

type4 <- length((filter(renamed_df, haul_id_short=='EXCmacDATSTO815'|haul_id_short=='Excmacdatsto815error'))$haul_id_short)

ship_erroneous <- data.frame("Graph_Type"=c("y proportional to exp(-x)", "Single prey weight"
                                      , "Same number of prey per stomach", "Same data"),
                        "Number_of_observations"=c(type1, type2, type3, type4))
#creates a data frame which shows the number of observations of each error 'type'

kable(ship_erroneous)
#creates a table of the ship_erroneous data frame as an output
```


In total, 35445 out of the total 267431 observations lie within these potentially erroneous groups. This is:
$$
  \frac{35445}{267431} \times 100 = 13.25389 \%
$$


This means that approximately $13 \%$ of the data set comes from potentially unreliable sources. Though we will not remove or alter the data set to account for these potentially erroneous data points in this project, for further analysis it may be sensible to remove the data points these six ships recorded so that any results are as reliable as possible.

# Prey and predator weight relation

We are attempting to find a link between the predator weight and the prey weight. Log() of each axis is used to see the proportionality of the axes, where the slope of the added line should = 1. This is because:

$$
 \log (\text{prey weight}) = m \times \text{log(predator weight)} + c ,
$$

where m is the gradient of the slope and c is the y-intercept (thinking of this graph as a linear model).

Taking the exponential of both sides,

$$
  \text{prey weight} = \exp({{m}\times{\log(\text{predator weight})}}) + \log(D) ,
$$
where log(D) = c. 

Finally,

$$
  \text{prey weight} = \text{predator weight}^m \times D
$$

Hence, we want m=1 to show that log(predator weight) is proportional to log(prey weight) (as expected).

```{r log(prey weight) v. log(pred weight), echo=TRUE, message=FALSE}
#message=FALSE means some output messages aren't printed in the knitted HTML document

ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey weight) v. log(predator weight) plot", 
       x="log(predator weight)", y="log(prey weight)") + 
  geom_hex(bins = 50) +
  scale_fill_gradient2(low = "black", mid = "orange", high = "red", midpoint = 200) +
  stat_smooth(method='lm', se=FALSE, colour="blue") +
  theme_classic()

#theme_classic() removes the grey background of the plot to make it easier to read and understand
# stat_smooth adds a line of best fit plotted through the points
# method='lm' ensures it is a straight line, i.e. a linear model
# se=FAlSE creates only a single line, with no error of margin included

#geom_hex creates "bins" in the data where the density is calculated over
#bins=50 means that there are 50 "bins" in the horizontal direction and 50 in the vertical
#scale_fill_gradient2 creates a density colour scale, meaning that areas with a high density of points are red and areas with a low density of points are darker in colour

slope <- coef(lm(renamed_df$lprey_weight~renamed_df$lpred_weight))
cat("Slope of the log(prey weight) v. log(predator weight) line of best fit:", slope[2])
#'cat()' prints some output message as purely the characters included in the '()' section

# coef(lm()) creates an array containing the coefficients of the linear model of the relationship between two axes
# The first item of the array gives out the y-intercept of the line, and the second item of the array is the gradient
```

For this graph, the slope is not equal to one. However, this graph is plotted over the entire data set and includes values from all of the available predator species.

Instead, separate the plots by predator species to see if there is some proportionality between the predator and prey weight for each specific species.

## Prey v. predator weight plot, separated by predator species

```{r sep by pred species, echo=TRUE, message=FALSE}
ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey weight) v. log(predator weight), separated by predator species", 
       x="log(predator weight)", y="log(prey weight)") +
  geom_point(size=0.01, colour="red") + 
  facet_wrap(~pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 10)) +
  stat_smooth (method='lm', se=FALSE, colour="black")
```

## Gradients of the plots for each predator species

```{r pvp gradients, echo=TRUE}
i <- 1
species_grad = c()
#setting i=1 for the while loop
#and creating an empty vector called 'species_grad' to hold data

while(i<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[i]))
  grad <- coef(lm((species_df$lprey_weight)~(species_df$lpred_weight)))
  species_grad[i] <- grad[2]
  i=i+1
}

#'while' means that this function repeats through the length of 'species_list' until all predator species are accounted for
#i=i+1 increases the value of i each time through this loop to motivate this repeat
#this creates a data frame (species_df) containing each indivdual predator species, then calculates the gradient of the log(pred weight) v. log(prey weight) graph for this individual predator species, then inserts this gradient value to the ith value of an array named 'species_grad'

pvp_grads <- data.frame("Predator_Species"=c(species_list),
                        Gradient=c(species_grad))

kable(pvp_grads)
#creates a new data frame name 'pvp_grads', with one column named 'pred_species' and the other named 'gradient'
#each row contains the name of some individual predator species and its associated gradient
#kable prints the information in the pvp_grads
```

Here, we are splitting up the graphs over each individual predator species to look and see if there is a proportionality between the predator and prey masses for each specific predator species.

We are wanting gradient$=1$ to suggest proportionality between the two variables. This is true ($\pm 0.5$) for the species:

 * Cod
 * Common Dab
 * European Hake
 * Haddock
 * Horse Mackerel
 * Megrim
 * Monkfish
 * Norway Pout
 * Plaice
 * Poor Cod
 * Sprat
 * Whiting
 
This represents 13 out of the 16 possible predator species, hence the assumption that the predator and prey masses are proportional is a reasonable one. Therefore, we will continue with this assumption.

Having proportionality between the predator and prey masses allows us to use the PPMR (predator prey mass ratio) for further analysis in this project.

#  PPMR for individual species

Here, we are looking for the most common log(PPMR) for each individual species. This will be done by plotting log(PPMR) against the density of points, and weighting observations on different variables. By assuming these are normally distributed relations, there should be a 'peak' point of log(ppmr) which is where the mean/most common log(ppmr) value lies. We assume this will be different for different species of predator, i.e. each predator has a preferred ppmr value and hence each predator type has a preferred relative size of prey.

##  Weighted by prey biomass

These plots are weighted by the prey biomass. This means that we are looking at the distribution of prey biomass across values of log(PPMR), so points with a larger biomass are  prioritised/weighted more than those with a smaller biomass.

```{r ave PPMR biomass, echo=TRUE}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by biomass density of prey", 
       x="log(PPMR)", y="Biomass density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = prey_weight_g), colour="red")

#using facet_wrap for the variable (pred_species) means the data is separated into individual plots for each predator species
#geom_density means area under the curve = 1 (i.e. the graph is normalised)
#weight=prey_weight_g means the points are 'weighted' by the column weight (biomass) of each individual prey
``` 

## Weighted by number of prey

These plots are weighted by the number pf prey per stomach. This means that data points with a larger number of prey per stomach are prioritised/weighted more than those with a smaller number of prey per stomach.

```{r ave PPMR prey no., echo=TRUE}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by number density of prey", 
       x="log(PPMR)", y="Number density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = no._prey_per_stmch), colour="green")

#weight=no._prey_per_stmch means the points are 'weighted' by the number of prey per stomach
```

By looking at the two differently weighted graphs, it is clear to see that the plots are 'shifted' by some amount (e.g. the Blue Whiting when weighted by prey biomass has a mean log(ppmr) of roughly 4.8, and when weighted by number of prey this mean becomes roughly 7.5).

# Specific PPMR calculations by different weightings for Herring species

Here, we take only observations relating to the predator type Herring. This allows us to do more specific analysis about how density observations can be weighted, and explain why the weighted means are shifted by some amount.

```{r Herring PPMR setup, echo=TRUE}
herringDF <- renamed_df %>% 
    filter(pred_species == fixed("Herring"))
#creates a separate data set (called 'herringDF') only containing observations for the predator species 'Herring'
```

## Weighted by prey biomass

The curve with points weighted by the prey biomass is plotted in blue, and a normal curve (also weighted by prey biomasss) is plotted over the top as a dashed black line.

```{r Prey biomass weighting, echo=TRUE, messages=FALSE, warning=FALSE} 
bio_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE)
bio_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE))

#weighted.mean gives the arithmetic mean of log(ppmr), where datapoints are weighted by the prey weight of observations
#similarly, wtd.rvar is the variance of log(ppmr), where the datapoints are also weighted by the prey weight
#standard deviation is defined as the square root of the variance
#na.rm=TRUE means any rows with missing values (values that equal 'na') aren't included in the mean/variance calculations, but are instead ignored

ggplot(data = herringDF, aes(x=lppmr)) + 
          labs(title = "Density plot of log(ppmr) for Herring,
               weighted by prey biomass", 
               x="log(PPMR)",y="Biomass density of observations") +
          geom_density(aes(weight = prey_weight_g), colour="red") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) + 
          stat_function(fun = dnorm, 
                        linetype="dashed",
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD))) +
          xlim(-5,17)

#axis.text.y adjusts the size of the axis labels on the y-axis so they are most easily readable
#stat_function adds a normal distribution curve (fun=dnorm) with a mean and standard deviation equal to what was calculated earlier for this data set
#linetype makes the line for the normal distribution into a dotted (black) line
#xlim sets limits for the x-axis so that all the necessary data points can be seen

cat("Mean value of log(ppmr), weighted by biomass of prey:", bio_herringmean)

cat("\n")
#creates a line break so that the outputs appear on different lines in the knitted html document

cat("Standard deviation of this:", bio_herringSD)
```

## Weighted by number of prey

The curve with points weighted by the number of prey per stomach is plotted in red, and a normal curve (also weighted by the number of prey per stomach) is plotted over the top as a dotted black line.

```{r No of prey weighting, echo=TRUE} 
no_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE)
no_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE))
#the mean and variance are both weighted by the number of prey

ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(ppmr) for Herring, 
               weighted by number of prey per stomach",
               x="log(PPMR)", y="Number density of observations") +
          geom_density(aes(weight = no._prey_per_stmch), colour="green") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) +
          stat_function(fun = dnorm, 
                        linetype = "dotted",
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD))) +
          xlim(0,25)

#the xlim is different to the graph above because these data points lie over a slightly different log(ppmr) range

cat("Mean value of log(ppmr), weighted by the number of prey per stomach:", no_herringmean)
cat("\n")
cat("Standard deviation of this:", no_herringSD)
```

## Combined graph

```{r Herring combined graph, echo=TRUE, fig.height=6, fig.width=12} 
ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(ppmr) for Herring,
               with various weightings",
               x="log(PPMR)", y="Number/biomass density of observations") +
          geom_density(aes(weight = no._prey_per_stmch, colour="prey biomass")) + 
          geom_density(aes(weight = prey_weight_g, colour="number of prey per stomach")) + 
          stat_function(fun = dnorm, 
                        linetype = "dotted",
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD)),
                        aes(colour="number of prey per stomach - normal curve")) +
          stat_function(fun = dnorm, 
                        linetype = "dashed",
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD)),
                        aes(colour="prey biomass - normal curve")) +
          theme(plot.title = element_text(size=20)) +
          scale_color_manual(name='Lines', values=c('green', 'black', 'red', 'black')) +
          xlim(-5,25) 

#scale_color_manual manually adds a key to the graph to describe what the differently coloured lines represent
#each curve is given a name using 'aes(colour="")', and these are then given a specific colour using 'values='
```

This is a graph with both the the distribution of Herring log(PPMR) as weighted by prey biomass and number of prey plotted over each other (along with appropriately weighted normal distribution curves plotted over the top of each).

* Prey biomass weighted mean: 6.629177
* Number of prey weighted mean: 13.54102

and

* Prey biomass standard deviation: 2.3508789268221
* Number of prey standard deviation: 2.63330496940788

The mean is shifted by: $13.54102 - 6.629177 = 6.911843$.

The mathematics of shifted means for this difference in weighting is:

$$
  \text{weighted mean}_{\text{expected prey biomass}} = \text{weighted mean}_{\text{no. of prey }} - (\text{standard deviation}_{\text{no. of prey }})^2
$$

Hence, the expected result is:

$$
  \text{weighted mean}_{\text{actual prey biomass}} = 13.54102 - (2.63330496940788)^2 = 6.60672493809
$$

There is a difference in expected and actual prey biomass weighted mean of 0.30511806191. This is a fairly insignificant value, which suggests the shifting mean equations are relatively accurate for this data set with these weightings.

Therefore, we can continue with the assumption that there is a difference in the mean of log(ppmr) of the square of the standard deviation when we weight by number of prey per stomach and prey biomass.

# Predator weight against ppmr

## Plotting ppmr against predator weight, separated by predator species

```{r pred weight v. ppmr, echo=TRUE, message=FALSE}
ggplot(data=renamed_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.001, colour="cornflowerblue") +
  labs(title = "log(PPMR) v. log(predator weight) plot", 
       x="log(Predator weight)", y="log(PPMR)") + 
  stat_smooth (method='lm', se=FALSE, colour="black") + 
  facet_wrap(~pred_species, scale="free_y")
```

Graphing $\log$(predator weight) v. $\log$(PPMR) for individual predator species to see if the predator weight related to the ppmr. 

$$
    \log(\text{PPMR}) = m \times \log (\text{predator weight}) + c
$$

where m is the gradient (assuming a linear model between the variables) and c is the y-intercept. 

We want them to not be proportional (i.e. slope,  m= 0) to prove that log(predator weight) is not related to the log(ppmr). This would mean that the ppmr is independent of the predator weight for a certain species (as assumed).

## Gradients of the plots

```{r ppmrvp gradients, echo=TRUE}
j <- 1
species_grad_ppmr = c()

while(j<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[j]))
  grad <- coef(lm((species_df$lppmr)~(species_df$lpred_weight)))
  species_grad_ppmr[j] <- grad[2]
  j=j+1
}

ppmrvp_grads <- data.frame("Predator_species"=c(species_list),
                        gradient=c(species_grad_ppmr))

kable(ppmrvp_grads)
```

For the assumption to be upheld, we need gradient $= 0$. This is (approximately, by $\pm 0.5$) satisfied for the species:

 * Cod
 * Common Dab
 * European Hake
 * Haddock
 * Horse Mackerel
 * Megrim 
 * Monkfish
 * Norway Pout
 * Plaice
 * Poor Cod
 * Sprat
 * Whiting
 
This means that the gradient of 12 out of the possible 16 species is equal to $0 \pm 0.5$. However, this amount of error is fairly large, so we have not supported the idea that the assumption of independence between the $log\text{ppmr}$ and $\log(\text{predator weight})$ can be upheld for this data set.

## Different weightings of the line of best fit

```{r poor cod, echo=TRUE, message=FALSE}
species_df <- renamed_df %>% filter(pred_species == fixed("Poor Cod"))
#creating a data frame only containing observations where the predator species is poor cod.

ggplot(data=species_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.5) +
  labs(title = "log(PPMR) v. log(predator weight) plot: Poor Cod", 
       x="log(Pred weight)", y="log(PPMR)") + 
  stat_smooth(aes(weight=no._prey_per_stmch, colour='by number of prey in stomach'), 
              method='lm', se=FALSE, linetype="dotted") +
  stat_smooth(aes(weight=prey_weight_g, colour='by prey biomass'), 
              method='lm', se=FALSE, linetype="dashed") +
  stat_smooth(aes(colour='no weighting'), method='lm', se=FALSE) +
  stat_summary(fun.data=mean_se, geom="linerange") +
  scale_colour_manual(name="Weightings", values=c('green', 'red', 'blue')) +
  theme_classic()

# se=FALSE doesn't add an area of error around the LOBF 
# fun.data=mean_se calculates the mean and standard error for each point
# linerange draws a point range between an upper and lower limit for the line, and the mean for the point (using the values calculated in 'fun.data=mean_se')

cat("slope of the log(ppmr) v. log(predator weight) line of best fit for poor cod:")
cat("\n")

#weighted by number of prey per stomach
perstmch_weighting <- 
  coef(lm(species_df$lppmr~species_df$lpred_weight, weight=species_df$no._prey_per_stmch))
cat("i) Weighted by no prey in the stomach:", perstmch_weighting[2])
cat("\n")

#weighted by prey biomass
biomass_weighting <- 
  coef(lm(species_df$lppmr~species_df$lpred_weight, weight=species_df$prey_weight_g))
cat("ii) Weighted by prey biomass:", biomass_weighting[2])
cat("\n")


#no weighting
no_weighting <- coef(lm(species_df$lppmr~species_df$lpred_weight))
cat("iii) No weighting in the calculation:", no_weighting[2])
```

Looking at just the predator species 'poor cod'. There are three LOBF (line of best fit), weighted by different variables:

1. green and dotted: by number of prey per stomach
2. red and dashed: by prey biomass
3. blue: no weighting in the LOBF

When weighted by prey biomass, the gradient is equal to zero for 2 s.f.. Hence, the approximation (of slope$ = 0$) is supported by the data when looking at a prey biomass weighting.

However, given that this slope is only equal to $0$ for one of these three weightings, the above linear models in fact show that the $\log(\text{predator weight})$ and the $\log(\text{PPMR})$ are independent of one another.

## Residuals of the log(predator weight) against log(ppmr) plot {.tabset}

We are now proceeding with the idea that the $\log(\text{predator weight})$ and $\log(\text{PPMR})$ are independent of one another, hence the predator weight is independent of the PPMR. 

Heteroscedasticity is when the residuals (error terms) are unequally scattered. For example, residuals may get more 'spread out' as the fitted values get larger. This occurs in data sets where there is a large range of data values, and is a problem because we want residuals with a constant variance. This is seen when the residuals are approximately normally distributed, and hence if residuals do not show a normal distribution then it is unclear whether or not the method used to infer the parameters of the linear relationship is a good one.

```{r Herring info, echo=TRUE, message=FALSE}
herring_df <- renamed_df %>% filter(pred_species == fixed("Herring"))
herring_model <- lm(lppmr ~ lpred_weight, data=herring_df) 
res <- resid(herring_model)
predicted <- predict(herring_model)
#lm() fits a regression models for log(ppmr) against log(predator weight)
#resid() creates a list of the residual of each individual data point
#predict() gives the predicted values
```

### With residuals of each point to the line of best fit

```{r residual to points, echo=TRUE, message=FALSE}
ggplot(herring_df, aes(x = lpred_weight, y = lppmr)) +
  geom_smooth(method = "lm", se = FALSE, colour="black") +  
  geom_segment(aes(xend = lpred_weight, yend = predicted), colour="red", size=0.1) +
  geom_point(size=0.5) +
  labs(title='The log(predator weight) against log(ppmr) graph, 
       with lines from the individual points to the line of best fit: Herring', 
       x='log(predator weight)', y='log(ppmr)')
#showing the residuals of each point to the line of best fit
#geom_smooth() creates the regression line of the regression model from lm()
#geom_segment() draws a line from each point to the regressionline 
```

### Residuals v. fitted values

```{r residuals v. fitted values, echo=TRUE, message=FALSE}
ggplot(herring_model, aes(x = .fitted, y = .resid)) +
  geom_point(colour="red", size=0.5) +
  geom_hline(yintercept = 0, colour="grey") +
  labs(title='Plot of the residuals against the fitted values: Herring',
       x='Fitted Values', y='Residuals') +
  theme_classic()
#this plots the residuals of each data point, and adds a line across at res=0 to help visualise the data
#.resid creates a list of the residuals of each individual data point
```

### qqplot

```{r qqplot, echo=TRUE, message=FALSE}
qqnorm(res)
qqline(res)
#plot a Q-Q plot to determine if the residuals follow a normal distribution
#for a normal distribution, we would expect the data points to fall along roughly a straight line at a 45 degree angle
```

### Density of residuals

```{r density of residuals, echo=TRUE, message=FALSE}
ggplot(herring_model, aes(x = .resid)) +
  geom_density(colour="red") +
  labs(title='Density plot of the residuals: Herring', x='Residuals', y='Density')
#plots the density of the residuals of the lppmr v lpred_weight graph for Herring
```

We can see that for the predator species Herring, the residuals do not look like they are normally distributed.

### Residuals v. log(predator weight)

```{r residuals v. lpred_weight, echo=TRUE, message=FALSE}
ggplot(herring_model, aes(x = lpred_weight, y = .resid)) +
  geom_point(colour="red", size=0.5) +
  geom_smooth() + 
  labs(title='Residuals v. log(predator weight): Herring', x='log(predator weight)', y='Residuals')
```

## Residual plots for the individual predator species

```{r applying residual plots, echo=TRUE, message=FALSE}
model<- lm(lppmr~lpred_weight, data=renamed_df) 

ggplot(model, aes(x = .resid)) + 
  geom_density(colour="red") + 
  facet_wrap(~renamed_df$pred_species, scales = "free_y") +
  labs(title="Density plot of the residuals", x='Residuals', y='Density')
#Plotting the density of the residuals for each predator species
```

This is a histogram plot of the residuals of the plot, separated for each predator species. We are looking for residuals which are normally distributed around resid=0. 

Of the resulting histograms, the following show (approximately) a normal distribution:

  * Cod
  * Common Dab
  * Horse Mackerel
  * Norway Pout
  * Poor Cod
  * Sole
  * Whiting

Therefore, it could be said that a linear model ($y=mx+c$) is applicable for comparing the $\log(\text{predator weight})$ and $\log(\text{ppmr})$. However, since not all the residuals are strongly normally distributed, we will instead use a different model for this data set to attempt to more accurately approximate certain parameters in the variable relationships.

# Introducing a mixed effects model

We will introduce a mixed effects model to account for some variance that external effects may cause to the data.

## Building up the model {.tabset}

### Basic Linear model

This is mathematically represented by:
$$
  \log(\text{ppmr}) = m \times \log(\text{predator weight}) + c
$$

```{r linear model, echo=TRUE}
renamed_df %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    geom_line(size=1) + 
    labs( x='log(predator weight)', y='log(ppmr)') +
    theme_classic()
#theme_classic() removes the grey background of the plot to make it easier to read
```

This plot is very difficult to interpret, and the relationship between the $\log(\text{ppmr})$ and $\log(\text{predator weight})$ is difficult to visualise as there is not a single gradient for each predator species. To aid in our interpretation, we will add random effects to account for some of the variance in the $\log(\text{ppmr})$ values.

### First trial

Fixed effects: log(predator weight)

Random effects: predator species (fixed slopes and random intercepts)

```{r first, echo=TRUE}
one <- lmer(lppmr ~ lpred_weight + (1|pred_species), data = renamed_df, REML=FALSE)
#same slope for every predator species, but varying intercept

renamed_df %>% 
    mutate(lppmr= fitted(one)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    labs( x='log(predator weight)', y='log(ppmr)') +
    geom_line(size=1) 
```

Here, there is the same slope for every predator species, but each species has a different intercept.

This is mathematically represented by:
$$
  \log(\text{ppmr})_i = \beta_{0j[i]} + \alpha_1 \times \log(\text{predator weight})_i 
        + \epsilon_{ij}
$$

Where:

* $i$ is the individual observation
* $j$ is the group (the predator species)
* $\alpha_1$ is the slope - this is the same for all predator species
* $\beta_{0j[i]}$ is the intercept term - this is different for each predator species
* $\epsilon_{ij}$ is the error term

Note, the intercept is defined at $\log(\text{predator weight}) = 0$.

### Second trial

Fixed effects: log(predator weight)

Random effects: predator species (random slope and fixed intercept)

```{r second, echo=TRUE}
two <- lmer(lppmr ~ lpred_weight + (0 + lpred_weight|pred_species), data = renamed_df, REML=FALSE)
#(0+ | ) means that the slope of the graph is different for each predator species

renamed_df %>% 
    mutate(lppmr = fitted(two)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    labs( x='log(predator weight)', y='log(ppmr)') +
    geom_line(size=1) 
```

This is mathematically represented by:
$$
  \log(\text{ppmr})_i = \beta_{0} + \alpha_{1j[i]} \times \log(\text{predator weight})_i 
        + \epsilon_{ij}
$$

Where:

* $\alpha_{1j[i]}$ is the slope - this is different for each predator species
* $\beta_{0}$ is the intercept term - this is the same for every predator species

For this plot, the value of log(predator weight) is modeled to be dependent on the predator species.

### Third trial

Fixed effects: log(predator weight)

Random effects: predator species (random slope and random intercept)

```{r third, echo=TRUE}
three <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|pred_species), data = renamed_df, REML=FALSE)
#Random intercept and random slope (correlated)

renamed_df %>% 
    mutate(lppmr = fitted(three)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    labs(x='log(predator weight)', y='log(ppmr)') +
    geom_line(size=1) 
```

This is mathematically represented by:
$$
  \log(\text{ppmr})_i = \beta_{0j[i]} + \alpha_{1j[i]} \times \log(\text{predator weight})_i 
        + \epsilon_{ij}
$$

Where:

* $\alpha_{1j[i]}$ is the slope - this is different for every predator species
* $\beta_{0j[i]}$ is the intercept term - this is different for every predator species

For this plot, the value of log(predator weight) is modeled to be dependent on the predator species.

### Comparing the models

```{r forming models, echo=TRUE}
anova(one,two,three)
#comparing the three models
```

## Trialing different models {.tabset}

Here, all the random effects are modeled with a randomly distributed slope and intercept.

### Trial a

This is mathematically represented by:
$$
  \log(\text{ppmr})_i = \beta_{0} + \beta_{1} \log(\text{predator weight})_{j} 
            + A_{0[j]} + \epsilon_{ij}
$$

Where:

* $\beta_{0}$ is the intercept term (the y-intercept)
* $\beta_{1}$ is the fixed effect (slope) for $\log(\text{predator weight})$
* $A_{0[j]}$ is the random intercept term for each observation $j$ - this is dependent on the haul_id
* $B_{0[j]}$ is the random intercept term for each observation $j$ - this is dependent on the year
* $\epsilon_{ij}$ is the residual/error term for each observation $j$
And:

* Fixed effects: lpred_weight
* Random effects: haul_id_short

```{r trial a, echo=TRUE}
a <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short), data = renamed_df, REML=FALSE)

a

plot(density(resid(a)), main="ensity plot of the residuals of model a", 
     xlab="residuals of model a", col="red") 
#Creates a density plot of the distribution of the residuals


print(VarCorr(a),comp="Variance")
cat("AIC:", AIC(a))
```

### Trial b

Mathematical representation
$$
  \log(\text{ppmr})_{ij} = \beta_{0} + \beta_{1} \log(\text{predator weight})_{j} 
              + A_{0[j]} + B_{0[j]} + \epsilon_{ij}
$$

Where:

* $B_{0[j]}$ is the random intercept term for each observation $j$ - this is dependent on the year

And:

* Fixed effects: lpred_weight
* Random effects: haul_id_short, year

```{r trial b, echo=TRUE}
b <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short) + (1+lpred_weight|year), data = renamed_df, REML=FALSE)

b

plot(density(resid(b)), main="Density plot of the residuals of model b",
     xlab="Residuals of model b", col="red") 

print(VarCorr(b),comp="Variance")
cat("AIC:", AIC(b))
```

### Trial c

Mathematical representation
$$
  \log(\text{ppmr})_{ij} = \beta_{0} + \beta_{1} \log(\text{predator weight})_{j} 
              + A_{0[j]} + B_{0[j]} + C_{0[j]} + \epsilon_{ij}
$$

Where:

* $C_{0[j]}$ is the random intercept term for each observation $j$ - this is dependent on the ices_rectangle

And:

* Fixed effects: lpred_weight
* Random effects: haul_id_short, year, ices_rectangle

```{r trial c, echo=TRUE}
c <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short) + (1+lpred_weight|year) + (1+lpred_weight|ices_rectangle), data = renamed_df, REML=FALSE)
c

plot(density(resid(c)), main="Density plot of the residuals of model c",
     xlab="Residuals of model c", col="red") 

print(VarCorr(c),comp="Variance")
cat("AIC:", AIC(c))
```

### Trial d

Mathematical representation
$$
  \log(\text{ppmr})_{ij} = \beta_{0} + \beta_{1} \log(\text{predator weight})_{j} 
              + A_{0[j]} + B_{0[j]} + C_{0[j]} + D_{0[j]} + \epsilon_{ij}
$$

With:

* Fixed effects: lpred_weight
* Random effects: haul_id_short, year, ices_rectangle, pred_species

```{r trial d, echo=TRUE}
d <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short) + (1+lpred_weight|year) + (1+lpred_weight|ices_rectangle) + (1+lpred_weight|pred_species), data = renamed_df, REML=FALSE)
d

plot(density(resid(d)), main="Density plot of the residuals of model d",
     xlab="Residuals of model d", col="red") 

print(VarCorr(d),comp="Variance")
cat("AIC:", AIC(d))
```


This model has the following variables:

Variable name |  Meaning            | Value       |  Where to find
------------- | -----------         | -------     | -------------
$i$           | the group           | -           | -
$j$           | the item            | -           | -
$\beta_{0}$   | the intercept term  |  4.6499  | fixed effects -> intercept -> estimate
$\beta_{1}$   | the fixed effect (slope) for $\log(\text{pred weight})$ | 0.2307  | fixed effects -> lpred_weight -> estimate
$A_{0[j]}$    | the random intercept for item $j$ (dependent on the haul_id_short term) | - | -
$\omega_{A[00]}$ |  s.d. for A, haul_id_short | 2.56161 |random effects -> groups -> ices_rectangle -> std. dev.
$B_{0[j]}$    | random intercept for dep. on the year term | -           | -
$\omega_{B[00]}$ | [s.d. for B, year] |  0.31411  | -
$\omega_{C[00]}$ | [s.d. for C, ices_rectangle] | 0.45300   | -
$C_{0[j]}$    | dep. on the ices_rectangle term | -             | -
$\epsilon_{ij}$ | the residual/error term for each individual item | 0.45300 | random effects -> groups -> residual -> std. dev.
 
Note: 

$A_{0[j]}$ is normally distributed with a mean of 0 and a standard deviation $\omega_{00}$ (i.e. $I_{0[j]} \sim \mathcal{N} (0,\omega_{A[00]}^2)$)

## Outputs

Outputs:

  * standard deviation for the random effects and residuals (want low values)
  * no. of observations
  * fixed effect, i.e. output of a linear model
  * frequency plot of the residuals (want clustered around resid=0)

Variance of the groups decreases as other random effects are added to the models.
But, the error term (standard error) roughly increases as more random effects are added to the model.

## Adding weighting to the models

```{r weighted mixed effects models, echo=TRUE}
#Do we need weighting? Bc it's not a density plot

weight_mixed <- lmer(lppmr ~ lpred_weight + (1|year), data = herringDF, REML=FALSE)

summary(weight_mixed)

#weighting observations by prey_weight_g
two <- update(weight_mixed, weights = prey_weight_g)
summary(two)

#weighting observations by no._prey_per_stmch
three <- update(weight_mixed, weights = no._prey_per_stmch)
summary(three)

```

# Citations

```{r citations, echo=TRUE}
#citation()

#devtools::session_info()
```