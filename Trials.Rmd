---
title: "Predator-Prey Mass Ratios in Aquatic Ecosystems and Fitting Mixed Effects Models to Account For Variance"
author: "Imogen Whitehead"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    code_folding: hide
    number_sections: yes
---

```{r setup, message=FALSE}
#message=FALSE means some output messages aren't printed in the knitted HTML document

knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE) 
#message=FALSE and warning=FALSE ensure any error or output messages aren't shown in the output HTML file
#echo=TRUE ensures that the code used to produce outputs can be accessed through the output file

#loading any necessary packages
library(dplyr)
library(tidyverse) 
library(knitr)
library(readr)
library(ggplot2)
library(bbmle)
library(mizer) 
library(Hmisc)
library(lme4)
library(RColorBrewer)
library(viridis)
library(hexbin)
library(ggpattern) 
library(sjPlot)      
```

```{r loading, message=FALSE}
load("stomach_dataset.Rdata")
#loading the dataset to be used in analysis (the dataset is already named stom_df)

df <- stom_df %>% 
  transmute(haul_id, ices_rectangle, year, pred_species, 
                            pred_weight_g, pred_length_cm, prey_weight_g, 
                            prey_type = prey_funcgrp, indiv_prey_weight = prey_ind_weight_g, 
                            prey_count, n_stomachs, 
                            no._prey_per_stmch = prey_count/n_stomachs, PPMR) 
#creating a new data set called 'df' which only contains certain selected columns
```

```{r correcting and adjusting the df, message=FALSE}
df <- df[df$indiv_prey_weight != 0, ]
df <- df[df$pred_weight_g != 0, ]
df <- df[df$indiv_prey_weight != Inf, ]
#Removes any points where the prey weight = Inf or 0, or the predator weight = 0

df<- df[!(is.na(df$year)),]
df<- df[!(is.na(df$ices_rectangle)),]
#Removes any points where the value is NA

df$lppmr <- log(df$PPMR)
df$lprey_weight <- log(df$indiv_prey_weight)
df$lpred_weight <- log(df$pred_weight_g)
#Adds columns which take the log value of PPMR, individual prey weight and predator weight to the main data set
```

```{r choosing predator species, message=FALSE}
renamed_df = df %>% 
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Micromesistius poutassou", "Blue Whiting")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Gadus morhua", "Cod")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Limanda limanda", "Common Dab")) %>%
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Merluccius merluccius", "European Hake")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Melanogrammus aeglefinus", "Haddock")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Clupea harengus", "Herring")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trachurus trachurus", "Horse Mackerel")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Scomber scombrus", "Mackerel")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lepidorhombus whiffiagonis", "Megrim")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lophius piscatorius", "Monkfish")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus esmarkii", "Norway Pout")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Pleuronectes platessa", "Plaice")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus minutus", "Poor Cod")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Solea solea", "Sole")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Sprattus sprattus", "Sprat")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Merlangius merlangus", "Whiting"))
#Renaming the predator species from their latin names (e.g. Gadus morhua) to their more common names (e.g. Cod)
#Creates a new data frame (called 'renamed_df') with these replaced names

species_list <- c("Blue Whiting", "Cod", "Common Dab", "European Hake", "Haddock", "Herring",
                     "Horse Mackerel", "Mackerel", "Megrim", "Monkfish", "Norway Pout",
                      "Plaice", "Poor Cod", "Sole", "Sprat", "Whiting")
#Creates an array called 'species_list', which is list of the predator species we are focusing on in this project

renamed_df <- renamed_df[renamed_df$pred_species %in% species_list, ]
#Removes any observations of predator species not in the species_list, i.e. they are irrelevant data points for this project
```

# Introduction

This data set is formed from recordings taken by multiple ships between the years 1886-2016.

Fish were taken from some location, and their individual stomach contents recorded. Prey of (roughly) the same size found in a single predator's stomach were recorded as part of a single observation. This gives the number of prey that make up a single observation for some single predator stomach, and is called 'no._prey_per_stmch'.

Using similar logic,'prey_weight_g' is the total weight of prey in a single observation, and 'indiv_prey_weight' is then the approximate weight of one single prey individual found in the stomach, found using:

$$
  \text{indiv_prey_weight} = \frac{\text{prey_weight_g}}{\text{no._prey_per_stmch}}
$$

There are some other column names which are useful to note:

* ices_rectangle accounts for the location of observations, where each area that the points are sampled in is split up into a number of smaller rectangles and each is given a unique name
* haul_id is a identification tag given to each individual ship which recorded observations
* The weight of each individual prey (indiv_prey_weight) and each predator (pred_weight_g) are measured in grams
* PPMR stands for 'predator prey mass ratio', and is calculated using:

$$
    \text{PPMR} = \frac{\text{predator mass}}{\text{prey mass}}
$$
(where the prey mass is the 'indiv_prey_weight', representing the prey mass of a single prey in the stomach of a single observation)

# Distribution of prey type eaten for each predator

```{r distribution of prey}
ggplot(renamed_df, aes(x=prey_type, fill=prey_type)) +
   geom_bar_pattern(stat = "count",
                    pattern_color = "white",
                    pattern_fill = "white",
                    aes(pattern = prey_type, pattern_angle = prey_type)) +
  facet_wrap(~renamed_df$pred_species, scale="free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="none") +
  labs(title = "Distribution of prey types for each predator species", x="Prey type",
       y="Number of observations")
 
#geom_bar_pattern() creates a bar chart from the specified data, where each category has a different pattern used to fill it
#Using different patterns as well as different colours to fill the bars ensures the data can be understood if looked at in grey scale, and makes the document accessible for colour blind people
#facet_wrap() means an individual bar chart is created for each individual predator species
#'theme()' adjusts the labels along the x-axis so they lie slightly angled to the vertical direction so they are easy to read
#legend.position="none" means that there is no key to explain what each bar shows, as the x-axis is very clear in describing each bar
```

These are individual bar charts showing the distribution of the type of prey each predator eats.

The prey types are:

* Benthos: organisms that live on/near the bottom of a body of water
* Fish: aquatic, craniate (have a skull), gill-bearing animals that lack limbs with digits (i.e. their limbs don't have toes or fingers). Fish are a type of nekton, but for this data set fish are recorded as separate entities.
* Nekton: the actively swimming aquatic organisms that can resist a strong current of water (the classification of nekton for this data set excludes any fish)
* Zooplankton: animal types of plankton (where plankton are aquatic organisms that are unable to swim effectively against currents)
* Other: miscellaneous types of aquatic animals that don't fit into the other categories, including sand, debris, crustaceans and unclassified digested remains

We can see that some predators eat a range of prey types (e.g. Whiting), while others prefer to eat a single prey type in abundance (e.g. European Hake and Monkfish mostly consume fish as their prey).

# Distribution of prey masses

```{r lprey density}
ggplot(renamed_df, aes(x=lprey_weight)) +
  geom_density(aes(weight = no._prey_per_stmch), color="red") +
  labs(title = "Density of log(prey mass) observations", x="log(prey mass)", 
      y="Number density of observations") + 
  facet_wrap(~pred_species, scale="free_y")   
```

This plot shows that different predator species consume differently sized distributions of prey. For example, some species have a 'peak' at roughly a single size of prey (such as Horse Mackerel and Norway Pout), and some species show a wider range of prey masses which they consume, such as:

* Cod
* Sprat, and 
* Megrim

# Most common prey masses

```{r}
renamed_df$haul_id_short <- gsub("\\-.*", "", renamed_df$haul_id)
renamed_df$haul_id_short <- gsub("_", "", renamed_df$haul_id_short)
#the haul_id values are renamed to be shortened versions of the ship names (e.g. CLYDE) rather than the complete id (e.g. CLYDE-1935-6)
```

```{r log(prey mass) v. number of prey per observation}
ggplot(data = renamed_df, aes(lprey_weight, no._prey_per_stmch)) + 
      labs(title = "Number of prey per predator stomach v. log(prey mass) ", 
       x="log(prey mass)", y="Number of prey per predator stomach") + 
      geom_point(size=0.5)

#geom_point() adds individual points which show individual recorded points
#size=0.5 defines the size of each point on this graph
``` 

This graph is looking at the distribution of the mass of prey recorded, i.e. looking at what is the most common prey mass over all prey species. It is a graph over all the data points, so includes recordings from all the ships involved.

There are some potentially interesting results, so results from different ships were plotted on individual curves to further look into these results.

```{r sep by all ships, fig.height=12, fig.width=15}
ggplot (data = renamed_df, aes(x=lprey_weight, y=no._prey_per_stmch, color=haul_id_short)) + 
  labs(title = "Number of prey per observation v. log(prey mass) - separated by all ship names", 
       x="log(prey mass)", y="Number of prey per observation") + 
  geom_point(size=0.02) +
  theme(strip.text = element_text(size = 7), legend.position="none", 
        plot.title = element_text(size=22), axis.title = element_text(size=22)) + 
  facet_wrap(~renamed_df$haul_id_short, scale="free_y")
```

Taking a closer look at some of these ships gives the plots below:

```{r sep by ships}
interesting_haul <- filter(renamed_df, 
                           haul_id_short=='CLYDE'|haul_id_short=='END04'|haul_id_short=='LUC'|
                             haul_id_short=='HIDDINK'|haul_id_short=='EXCmacDATSTO815'|
                             haul_id_short=="Excmacdatsto815error")
#interesting_haul is a new data frame which only contains values recorded by ships which gave "interesting" looking datapoints

haul_list_interesting <- unique(interesting_haul$haul_id_short)
#creates an array containing every individual (renamed) ship name that we are interested in

ggplot (data = interesting_haul, aes(x=lprey_weight, y=no._prey_per_stmch, 
                                     color=haul_id_short)) + 
  labs(title = "Number of prey per observation v. log(prey mass) 
       - separated by ship names, for a selection of 6 ships",
       x="log(prey mass)", y="Number of prey per observation") + 
  geom_point(size=0.02) +
  theme(strip.text = element_text(size = 10), legend.position="none") + 
  facet_wrap(~interesting_haul$haul_id_short, scale="free_y")
```


These six graphs show a range of unusual looking points:

1. $y \propto e^{-x}$ relation for END04 (i.e. no. per stomach is proportional to $\frac{1}{\text{prey mass}}$)
2. lots of observations for single prey masses for LUC and CLYDE
3. lots of the same no. of prey per observation observations for HIDDINK
4. the EXCmacDATSTO815 and Excmacdatsto815error seem to represent exactly the same data

There are a number of other ships which also provided potentially erroneous data, and the total number of datapoints affected are as below:

```{r no of obs}
type1 <- length((filter(renamed_df, haul_id_short=='END04'))$haul_id_short)
#counting the number of observations recorded for each sort of error or interesting relation

type2 <- length((filter(renamed_df, haul_id_short=='CLION09' | haul_id_short=='LUC' | haul_id_short=='UNITY' | haul_id_short=='CLYDE'))$haul_id_short)

type3 <- length((filter(renamed_df, haul_id_short=='BEAVER'|haul_id_short=='BRUCELLA'|haul_id_short=='BULLEN'|haul_id_short=='CIROL04'|haul_id_short=='CIROL10'|haul_id_short=='CLION03'|haul_id_short=='CLION07'|haul_id_short=='CLION12'|haul_id_short=='COREL02'|haul_id_short=='COREL06'|haul_id_short=='CORY04'|haul_id_short=='CYPRIS'|haul_id_short=='END02'|haul_id_short=='END12'|haul_id_short=='HEINCKE147'|haul_id_short=='HIDDINK'|haul_id_short=='OITHONA'|haul_id_short=='STRANDLINE'|haul_id_short=='TELLINA'))$haul_id_short)

type4 <- length((filter(renamed_df, haul_id_short=='EXCmacDATSTO815'|haul_id_short=='Excmacdatsto815error'))$haul_id_short)

ship_erroneous <- data.frame("Graph_Type"=c("y proportional to exp(-x)", "Single prey mass"
                                      , "Same number of prey per observation", "Same data"),
                        "Number_of_observations"=c(type1, type2, type3, type4))
#creates a data frame which shows the number of observations of each error 'type'

kable(ship_erroneous)
#creates a table of the ship_erroneous data frame as an output
```


In total, 35445 out of the total 267431 observations lie within these potentially erroneous groups. This is:
$$
  \frac{35445}{267431} \times 100 = 13.25389 \%
$$


This means that approximately $13 \%$ of the data set comes from potentially unreliable sources. Though we will not remove or alter the data set to account for these potentially erroneous data points in this project, for further analysis it may be sensible to remove the data points these six ships recorded so that any results are as reliable as possible.

# Prey and predator mass relation

We are attempting to find a link between the predator mass and the prey mass, and $\log()$ of each axis is used to see the proportionality of the axes. The mathematics behind this is as follows:

$$
 \log (\text{prey mas}) = m \times \text{log(predator mass)} + c ,
$$

where m is the gradient of the slope and c is the y-intercept (thinking of this graph as a linear model).

Taking the exponential of both sides,

$$
  \text{prey mass} = \exp({{m}\times{\log(\text{predator mass})}}) + \log(D) ,
$$
where $\log(D) = c$. 

Finally,

$$
  \text{prey mass} = \text{predator mass}^m \times D
$$

Hence, we want $m = 1$ to show that predator mass is linearly proportional to prey mass (as expected). However, to simply show that the two variables are dependent on each other, we are looking for instances where $m \neq 0$

```{r log(prey mass) v. log(pred mass), message=FALSE}
#message=FALSE means some output messages aren't printed in the knitted HTML document

ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey mass) v. log(predator mass) plot", 
       x="log(predator mass)", y="log(prey mass)") + 
  geom_hex(bins = 20) +
  scale_fill_viridis(direction=-1, option="C") +
  stat_smooth(method='lm', se=FALSE, colour="blue") +
  theme_classic()

# theme_classic() removes the grey background of the plot to make it easier to read and understand
# stat_smooth adds a line of best fit plotted through the points
# method='lm' ensures it is a straight line, i.e. a linear model
# se=FAlSE creates only a single line, with no error of margin included

#geom_hex creates "bins" in the data where the density is calculated over
#bins=20 means that there are 20 "bins" in the horizontal direction and 20 in the vertical
#scale_fill_viridis creates a density colour scale, where the least dense area is yellow and the most dense is purple

slope <- coef(lm(renamed_df$lprey_weight~renamed_df$lpred_weight))
lpred_lpreyuncert <- lm(lprey_weight ~ lpred_weight, data = renamed_df)

cat("Slope of the log(prey mass) v. log(predator mass) line of best fit:", slope[2],
    "\n",
    "Standard error of this line of best fit:", summary(lpred_lpreyuncert)$coefficients[4])

#'cat()' prints some output message as purely the characters included in the '()' section

# coef(lm()) creates an array containing the coefficients of the linear model of the relationship between two axes
# The first item of the array gives out the y-intercept of the line, and the second item of the array is the gradient
```

For this graph, the slope is equal to $0.6712536 \pm 0.001915732$. This is not equal to $1$, and therefore this plot supports the assumption that the predator and prey masses are dependent on each other in some way.

For this graph, the most dense area (the area with the greatest number of points in a single hexagonal 'bin') is purple, and the least dense area is in yellow. Therefore, we can see that there are lots of observations around the point where $\log(\text{predator mass}) = 6$ and $\log(\text{prey mass}) = 0$, and near where $\log(\text{predator mass}) = -1$ and $\log(\text{prey mass}) = -5$. However, we can see that the line of best fit (in blue) isn't plotted directly through these most dense areas, and therefore we can't claim that this line of best fit is very reliable.

This graph is plotted over the entire data set and includes values from all of the available predator species. Instead, we will separate the plots by predator species to see if there is some proportionality between the predator and prey mass for each specific species. 

## Prey v. predator mass plot, separated by predator species

```{r sep by pred species, message=FALSE}
ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey mass) v. log(predator mass), separated by predator species", 
       x="log(predator mass)", y="log(prey mass)") +
  geom_point(size=0.01, colour="red") + 
  facet_wrap(~pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 10)) +
  geom_smooth(method='lm', colour="black")

#the grey bands around the lines of best fit represent the standard error of this line
```

## Gradients of the plots for each predator species

```{r pvp gradients}
i <- 1
species_grad = c()
uncert=c()
#setting i=1 for the while loop
#and creating an empty vector called 'species_grad' to hold data

while(i<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[i]))
  
  grad <- coef(lm((species_df$lprey_weight)~(species_df$lpred_weight)))
  species_grad[i] <- grad[2]
  
  preyvpred.lm <- lm(lprey_weight ~ lpred_weight, data = species_df)
  uncert[i] <- summary(preyvpred.lm)$coefficients[4]
  
  i=i+1
}

#'while' means that this function repeats through the length of 'species_list' until all predator species are accounted for
#i=i+1 increases the value of i each time through this loop to motivate this repeat
#this creates a data frame (species_df) containing each individual predator species, then calculates the gradient of the log(pred mass) v. log(prey mass) graph for this individual predator species, then inserts this gradient value to the ith value of an array named 'species_grad'
#this also creates a linear model of log(prey mass) against log(predator mass) for each individual predator species, and extracts the standard error of the line of best fit for this linear model, storing this in an array called 'uncert'

pvp_grads <- data.frame("Predator_Species"=c(species_list),
                        Gradient=c(species_grad),
                        Error=c(uncert))

kable(pvp_grads)
#creates a new data frame name 'pvp_grads', with one column named 'pred_species' and the other named 'gradient'
#each row contains the name of some individual predator species and its associated gradient
#kable prints the information in the pvp_grads
```

Here, we are splitting up the graphs over each individual predator species to look and see if there is a proportionality between the predator and prey masses for each specific predator species.

We are wanting gradient $\neq 0$ to suggest dependence between the predator and prey mass, and specifically gradient $= 1$ to suggest that they are linearly proportional.

The gradient $\neq 0 \pm$ (their standard error) for all of the predator species. Therefore, the assumption that the predator and prey masses are dependent on each other is a reasonable one and it holds for every predator species.

Having proportionality between the predator and prey masses allows us to use the PPMR (predator prey mass ratio) for further analysis in this project.

#  PPMR for individual species

Here, we are looking for the most common log(PPMR) value for each individual species. This will be found by plotting the density of the log(PPMR) observations, and weighting these observations based on two different variables. By assuming that these are normally distributed relations, there should be a 'peak' point of log(PPMR) which is where the most common log(PPMR) value lies. We assume this will be unique for different predator species, i.e. each predator has a preferred PPMR value, and hence each predator species has a preferred prey size relative to the mass of the predator that it most frequently consumes.

##  Weighted by prey biomass

These plots are weighted by the prey biomass. This means that we are looking at the distribution of prey biomass across values of log(PPMR), so observations are counted up according to their biomass. This means that a single observation which includes prey of a large biomass will represent a large density, and a single observation of prey of a small biomass will be shown as having a small density,

```{r ave PPMR biomass}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by biomass density of prey", 
       x="log(PPMR)", y="Biomass density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = prey_weight_g), colour="red")

#using facet_wrap for the variable (pred_species) means the data is separated into individual plots for each predator species
#geom_density means area under the curve = 1 (i.e. the graph is normalised)
#weight=prey_weight_g means the points are 'weighted' by the column weight (biomass) of each individual prey
``` 

## Weighted by number of prey

These plots are weighted by the number pf prey per observation. This means that data points with a larger number of prey per observation are prioritised/weighted more than those with a smaller number of prey per observation.

```{r ave PPMR prey no.}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by number density of prey", 
       x="log(PPMR)", y="Number density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = no._prey_per_stmch), colour="green")

#weight=no._prey_per_stmch means the points are 'weighted' by the number of prey per observation
```

By looking at the two differently weighted graphs, we can see that the mean of the plots are 'shifted' by some amount (e.g. the Blue Whiting when weighted by prey biomass has a mean log(PPMR) of roughly 4.8, and when weighted by number of prey this mean becomes roughly 7.5).

# Specific PPMR calculations by different weightings for Herring species

Here, we are only looking at observations relating of the predator type Herring.

```{r Herring PPMR setup}
herringDF <- renamed_df %>% 
    filter(pred_species == fixed("Herring"))
#creates a separate data set (called 'herringDF') only containing observations for the predator species 'Herring'
```

## Weighted by prey biomass

The curve with points weighted by the prey biomass is plotted in blue, and a normal curve (also weighted by prey biomasss) is plotted over the top as a dashed black line.

```{r Prey biomass weighting, messages=FALSE, warning=FALSE} 
bio_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE)
bio_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE))

#weighted.mean gives the arithmetic mean of log(PPMR), where datapoints are weighted by the prey weight of observations
#similarly, wtd.rvar is the variance of log(PPMR), where the datapoints are also weighted by the prey weight
#standard deviation is defined as the square root of the variance
#na.rm=TRUE means any rows with missing values (values that equal 'na') aren't included in the mean/variance calculations, but are instead ignored

ggplot(data = herringDF, aes(x=lppmr)) + 
          labs(title = "Density plot of log(PPMR) for Herring,
               weighted by prey biomass", 
               x="log(PPMR)",y="Biomass density of observations") +
          geom_density(aes(weight = prey_weight_g), colour="red") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) + 
          stat_function(fun = dnorm, 
                        linetype="dashed",
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD))) +
          xlim(-5,17)

#axis.text.y adjusts the size of the axis labels on the y-axis so they are most easily readable
#stat_function adds a normal distribution curve (fun=dnorm) with a mean and standard deviation equal to what was calculated earlier for this data set
#linetype makes the line for the normal distribution into a dotted (black) line
#xlim sets limits for the x-axis so that all the necessary data points can be seen

cat("Mean value of log(PPMR), weighted by biomass of prey:", bio_herringmean,
    "\n",
    "Standard deviation of this:", bio_herringSD)
#"\n| creates a line break so that the outputs appear on different lines in the knitted html document
```

## Weighted by number of prey

The curve with points weighted by the number of prey per observation is plotted in red, and a normal curve (also weighted by the number of prey per observation) is plotted over the top as a dotted black line.

```{r No of prey weighting} 
no_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE)
no_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE))
#the mean and variance are both weighted by the number of prey

ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(PPMR) for Herring, 
               weighted by number of prey per observation",
               x="log(PPMR)", y="Number density of observations") +
          geom_density(aes(weight = no._prey_per_stmch), colour="green") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) +
          stat_function(fun = dnorm, 
                        linetype = "dotted",
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD))) +
          xlim(0,25)

#the xlim is different to the graph above because these data points lie over a slightly different log(PPMR) range

cat("Mean value of log(PPMR), weighted by the number of prey per observation:", no_herringmean,
    "\n",
    "Standard deviation of this:", no_herringSD)
```

## Combined graph

```{r Herring combined graph, fig.height=6, fig.width=12} 
ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(PPMR) for Herring,
               with various weightings",
               x="log(PPMR)", y="Number/biomass density of observations",
               color="Line", linetype="Line") +
          geom_density(aes(weight = no._prey_per_stmch, colour="prey biomass",
                           linetype="prey biomass")) + 
          geom_density(aes(weight = prey_weight_g, colour="number of prey per observation",
                           linetype="number of prey per observation")) + 
          stat_function(fun = dnorm, 
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD)),
                        aes(colour="number of prey per observation - normal curve",
                            linetype="number of prey per observation - normal curve")) +
          stat_function(fun = dnorm,
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD)),
                        aes(colour="prey biomass - normal curve",
                            linetype="prey biomass - normal curve")) +
          theme(plot.title = element_text(size=20)) +
          scale_color_manual(values=c('green', 'black', 'red', 'black')) +
          scale_linetype_manual(values = c("solid", "dashed", "solid", "dotted")) +
          xlim(-5,25)

#scale_color_manual manually adds a key to the graph to describe what the differently coloured lines represent
#scale_linetype_manual manually adds a key to the graph to describe what the differently shaped lines represent (e.g. some lines are dotted, dashed or solid)
#each curve is given a name using 'aes(colour="")', and these are then given a specific colour using 'values='
```

This is a graph with both the the distribution of Herring log(PPMR) as weighted by prey biomass and number of prey plotted over each other (along with appropriately weighted normal distribution curves plotted over the top of each).

* Prey biomass weighted mean $\log$(PPMR) value: $6.781942 \pm 2.370106$
(where 2.370106 is the weighted by the prey biomass standard deviation for this curve).

and

* Number of prey weighted mean $\log$(PPMR) value: $13.68691 \pm 2.473435$
(the number of prey weighted standard deviation is 2.473435).

The mathematics of shifted means for these different weightings is:

$$
  \text{weighted mean}_{\text{expected prey biomass}} = \text{weighted mean}_{\text{no. of prey }} - (\text{standard deviation}_{\text{no. of prey }})^2
$$

Hence, the expected result is:

$$
  \text{weighted mean}_{\text{expected prey biomass}} = 13.68691  - (2.473435)^2 = 7.569029
$$

The $\text{weighted mean}_{\text{expected prey biomass}}$ lies within the standard error ($\pm 2.370106$) of the prey biomass weighted mean as given by the plot above. Therefore, the shifting mean equations are relatively accurate for this data set with these weightings.

So, we can continue with the assumption that there is a difference in the mean of $\log$(PPMR) of the square of the standard deviation when we weight by number of prey per observation and prey biomass.

# Predator mass against PPMR

## Plotting PPMR against predator mass, separated by predator species

```{r pred mass v. PPMR, message=FALSE}
ggplot(data=renamed_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.001, colour="cornflowerblue") +
  labs(title = "log(PPMR) v. log(predator mass) plot", 
       x="log(Predator mass)", y="log(PPMR)") + 
  stat_smooth (method='lm', colour="black") + 
  facet_wrap(~pred_species, scale="free_y")
```

Graphing $\log$(predator mass) v. $\log$(PPMR) for individual predator species to see if the predator mass related to the PPMR. 

$$
    \log(\text{PPMR}) = m \times \log (\text{predator mass}) + c
$$

where m is the gradient (assuming a linear model between the variables) and c is the y-intercept. 
Then,

$$
    \text{PPMR} = (\text{predator mass})^m + D
$$

(where $c = \log(D)$)

To prove that log(predator mass) is not related to the log(PPMR), we want the two to not be proportional and hence we are looking for slope, $m = 0$. This would mean that the PPMR is independent of the predator mass for a certain species (as assumed).

```{r ppmrvp gradients}
j <- 1
species_grad_ppmr = c()
uncert_ppmr = c()

while(j<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[j]))
  
  grad <- coef(lm((species_df$lppmr)~(species_df$lpred_weight)))
  species_grad_ppmr[j] <- grad[2]
  
  ppmrvpred.lm <- lm(lppmr ~ lpred_weight, data = species_df)
  uncert_ppmr[j] <- summary(ppmrvpred.lm)$coefficients[4]
  
  j=j+1
}

ppmrvp_grads <- data.frame("Predator_species"=c(species_list),
                        Gradient=c(species_grad_ppmr),
                        "Standard_Error" = c(uncert_ppmr))

kable(ppmrvp_grads)
```

$\pm$ their standard error, the species Megrim, Norway Pout, Poor Cod have a gradient equal to $0$ (to 1 significant figure). This is not many of the possible species,, so we have not supported the idea that the assumption of independence between the $\log(\text{PPMR})$ and $\log(\text{predator mass})$ can be upheld for this data set.

## Different weightings of the line of best fit

```{r poor cod, message=FALSE}
PoorCod_df <- renamed_df %>% filter(pred_species == fixed("Poor Cod"))
#creating a data frame only containing observations where the predator species is poor cod.

ggplot(data=PoorCod_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.5) +
  labs(title = "log(PPMR) v. log(predator mass) plot: Poor Cod", 
       x="log(Predator mass)", y="log(PPMR)", color="Weightings", linetype="Weightings") + 
  stat_smooth(aes(weight=no._prey_per_stmch, color='by number of prey in stomach',  
                  linetype='by number of prey in stomach'), 
              method='lm', se=FALSE) +
  stat_smooth(aes(weight=prey_weight_g, color='by prey biomass', linetype='by prey biomass'), 
              method='lm', se=FALSE) +
  stat_smooth(aes(color='no weighting', linetype='no weighting'), method='lm', se=FALSE) +
  stat_summary(fun.data=mean_se, geom="linerange") +
  scale_color_manual(values=c("green", "red", "blue")) +
  scale_linetype_manual(values = c("dashed", "dotted", "solid")) +
  theme_classic()

# se=FALSE doesn't add an area of error around the LOBF 
# fun.data=mean_se calculates the mean and standard error for each point
# linerange draws a point range between an upper and lower limit for the line, and the mean for the point (using the values calculated in 'fun.data=mean_se')

#weighted by number of prey per observation
perstmch_weighting <- 
  coef(lm(PoorCod_df$lppmr~PoorCod_df$lpred_weight, weight=PoorCod_df$no._prey_per_stmch))
perstmch_uncert <- lm(lppmr ~ lpred_weight, data = PoorCod_df,
                     weight=PoorCod_df$no._prey_per_stmch)
summary(perstmch_uncert)$coefficients[4]

#weighted by prey biomass
biomass_weighting <- 
  coef(lm(PoorCod_df$lppmr~PoorCod_df$lpred_weight, weight=PoorCod_df$prey_weight_g))
biomass_uncert <- lm(lppmr ~ lpred_weight, data = PoorCod_df, weight=PoorCod_df$prey_weight_g)

#no weighting
no_weighting <- coef(lm(PoorCod_df$lppmr~PoorCod_df$lpred_weight))
no_uncert <- lm(lppmr ~ lpred_weight, data = PoorCod_df)
```

Looking at just the predator species 'Poor Cod'. There are three LOBF (line of best fit), weighted by different variables, each with different values for their gradient:

1. green and dotted: by number of prey per observation, $m = -1.652398 \pm 0.1275232$
2. red and dashed: by prey biomass, $m = -0.001483607 \pm 0.1079585$
3. blue: no weighting in the LOBF, $m = -0.08453972 \pm 0.1052513$

, where these values are $\pm$ (their standard error).

When the LOBF is weighted by the prey biomass and has no weighting, the gradient is equal to $0 \pm$ (their standard error). Hence, the approximation (of slope $ = 0$) is supported by the data when looking at a prey biomass weighting. 

This is a much more accurate result and provides much more compelling evidence that the PPMR is independent of the predator mass. Although this assumption is only supported by analysis on the predator species Poor Cod, we will assume that independence being upheld for Poor Cod suggests independence of the variables for all predator species.

## Residuals of the log(predator mass) against log(PPMR) plot {.tabset}

We are now proceeding with the idea that the $\log(\text{predator mass})$ and $\log(\text{PPMR})$ are dependent on one another in some way, hence the predator mass is dependent of the PPMR.  

Heteroscedasticity is when the residuals (error terms) are unequally scattered. For example, residuals may get more 'spread out' as the fitted values get larger. This occurs in data sets where there is a large range of data values, and is a problem because we want residuals with a constant variance. This is seen when the residuals are approximately normally distributed, and hence if residuals do not show a normal distribution then it is unclear whether or not the method used to infer the parameters of the linear relationship is a good one.

```{r Herring info,  message=FALSE}
herring_df <-  renamed_df %>% filter(pred_species == fixed("Herring"))

herring_model <- lm(lppmr ~ lpred_weight, data=herring_df) 
res <- resid(herring_model)
predicted <- predict(herring_model)
#lm() fits a regression models for log(PPMR) against log(predator mass)
#resid() creates a list of the residual of each individual data point
#predict() gives the predicted value of a data point by using the previous behaviour and patterns of the data to determine possible future values
```

### With residuals of each point to the predicted values of each point

```{r residual to points, message=FALSE}
ggplot(herring_df, aes(x = lpred_weight, y = lppmr)) +
  geom_smooth(method = "lm", se = FALSE, colour="black") +  
  geom_segment(aes(xend = lpred_weight, yend = predicted), colour="red", size=0.1) +
  geom_point(size=0.5) +
  labs(title='The log(predator mass) against log(PPMR) graph, 
       with lines from the individual points to the line of best fit: Herring', 
       x='log(predator mass)', y='log(PPMR)')
#showing the residuals of each point to the line of best fit
#geom_smooth() creates the regression line of the regression model from lm()
#geom_segment() draws a line from each point to the regressionline 
```

This plot shows how distributed the points are in comparison to the line of best fit. For a 'well fitting' line of best fit, we would expect the residuals to be approximately normally distributed. As discussed earlier, the residual of a point is equal to:
$$
    \text{Residual} = \text{actual value} - \text{predicted/fitted value} ,
$$
where the predicted/fitted value is equal to the value as predicted by the line of best fit.

### Residuals v. fitted values

```{r residuals v. fitted values, message=FALSE}
ggplot(herring_model, aes(x = .fitted, y = .resid)) +
  geom_point(colour="red", size=0.5) +
  geom_hline(yintercept = 0, colour="grey") +
  labs(title='Plot of the residuals against the fitted values: Herring',
       x='Fitted Values', y='Residuals') +
  geom_smooth() + 
  theme_classic()
#this plots the residuals of each data point, and adds a line across at res=0 to help visualise the data
#.resid creates a list of the residuals of each individual data point
```

This graph plots the residual of each observation against its fitted value (as predicted by the line of best fit). This plot is used to detect unequal residual variances and any outliers. We can see that the residuals generally increase as the fitted values increase, which suggests that the residuals are potentially not normally distributed. To look further into this possibility, we will next plot a qqplot.

### qqplot

```{r qqplot, message=FALSE}
qqnorm(res)
qqline(res)
#plot a Q-Q plot to determine if the residuals follow a normal distribution
#for a normal distribution, we would expect the data points to fall along roughly a straight line at a 45 degree angle
```

A qqplot (quantile-quantile plot) shows if two data sets come from the same distribution. For this data set, we plot the actual residuals against the expected residuals if the residuals were normally distributed. The points on this graph should fall on the straight line (at a 45 degree angle), and if they don't then the residuals do not appear to be normally distributed.

### Density of residuals

```{r density of residuals, message=FALSE}
ggplot(herring_model, aes(x = .resid)) +
  geom_density(colour="red") +
  labs(title='Density plot of the residuals: Herring', x='Residuals', y='Density') +
  theme_classic()

#plots the density of the residuals of the lppmr v lpred mass graph for Herring
```

We can see that for the predator species Herring, the residuals do not look like they are normally distributed. This suggests that the residuals are unequally scattered, and hence we continue with the idea that $\log{(\text{PPMR})}$ and $\log{(\text{predator mass})}$ are independent of each other. 

## Residual plots for the individual predator species

```{r applying residual plots, message=FALSE}
model<- lm(lppmr~lpred_weight, data=renamed_df) 

ggplot(model, aes(x = .resid)) + 
  geom_density(colour="red") + 
  facet_wrap(~renamed_df$pred_species, scales = "free_y") +
  labs(title="Density plot of the residuals", x='Residuals', y='Density')
#Plotting the density of the residuals for each predator species
```

This is a histogram plot of the residuals of the plot, separated for each predator species. As discussed earlier, a normal distribution of the density of residuals would suggest that the data fits a linear model. This would then infer that the axes would be related to one another.

However, none of the predator species produce a density plot which looks convincingly normally distributed. Therefore, we can say that this data suggest that the PPMR and predator mass are independent of one another when modelling using a linear model. This also suggests that using a linear model (where we approximate $y=mx +c$) is not appropriate for this set of data.

Instead, we use a different model (a mixed effects model) to fit this data set to in order to attempt to more accurately approximate certain parameters in the variable relationships.

# Introducing a mixed effects model

We will now fit the data to a mixed effects model, which allows us to account for some variance that external effects may cause to the data.

## Building up the model {.tabset}

### Basic Linear model

This is mathematically represented by:
$$
  \log(\text{PPMR})_i = \beta_1 \times \log(\text{predator mass})_i + \beta_0
$$

Where:

* $i$ is the index of the individual observation
* $\beta_{0}$ is the overall intercept term (defined at the point where $\log(\text{predator mass}) = 0$.)
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)

```{r linear model}
renamed_df %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    geom_point(size=0.1) + 
    labs(x='log(predator mass)', y='log(PPMR)') +
    theme_classic()
#theme_classic() removes the grey background of the plot to make it easier to read
```

This plot is very difficult to interpret, and the relationship between the $\log(\text{PPMR})$ and $\log(\text{predator mass})$ is difficult to visualise as there is not a single gradient for each predator species. To aid in our interpretation, We will add random effects to account for some of the variance in the $\log(\text{PPMR})$ values.


### First trial

Fixed effects: $\log$(predator mass)

Random effects: year (fixed slopes and random intercepts)

```{r first}
one <- lmer(lppmr ~ lpred_weight + (1|year), data = renamed_df, REML=FALSE)
#same slope for every predator species, but varying intercept

year_list <- c(sort(unique(renamed_df$year)))
year_list_2000 <- year_list[c(year_list>2000)]
#a vector only including the values for year which are greater than 2000

one_df <- data.frame(Year=c(year_list),
                        "Slope"=c(coef(one)$year[2]))
one_df <- one_df %>% transmute(Year, Slope=lpred_weight) 
one_df <- one_df[one_df$Year %in% year_list_2000, ]
kable(one_df)
#This outputs the intercept term for each predator species for the fitted model, and only for values where the year is after 2000

plot_model(one, type = "re", vline.color="grey", dot.size=1.1, value.size=3,
           show.values=T, value.offset=.3) + 
        labs(x='Year', y='Value', title='Random effects: Intercepts - Model 1') + 
        xlim(factor(year_list_2000))
#Plots a model of the estimated values of the random effects variable
```

Here, there is the same slope for every predator species, but each species group has a different y-intercept (i.e. the line for each predator species group crosses the $\log$(predator mass)=0 line at a different value for $\log$(PPMR)). These values are only approximated, and the plot shows that

This is mathematically represented by:

$$
  \log(\text{PPMR})_{iy} = (\beta_{0} + \alpha_{0y}) + 
        \beta_{1} \log(\text{predator mass})_{i} + \epsilon_{iy}
$$

Where:

* $i$ is the index of the individual observation
* $y$ is the index of the year
* $\beta_{0}$ is the overall intercept term
* $\alpha_{0y}$ is the random intercept term for year $y$
(where $\alpha_{0j}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{A[00]}$ (i.e. $\alpha_{0y} \sim (0, \sigma^2_{A[00]})$)).
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)
* $\epsilon_{iy}$ is the error term, which describes the residuals of the model

### Second trial

Fixed effects: $\log$(predator mass)

Random effects: year (random slope and fixed intercept)

```{r second}
two <- lmer(lppmr ~ lpred_weight + (0 + lpred_weight|year), data = renamed_df, REML=FALSE)
#(0+ | ) means that the slope of the graph is different for each predator species, but they each group has the same intercept

two_df <- data.frame(Year=c(year_list),
                        "Intercept"=c(coef(two)$year[1]))
two_df <- two_df %>% transmute(Year, Intercept=X.Intercept.) 
two_df <- two_df[two_df$Year %in% year_list_2000, ]
kable(two_df)

plot_model(two, type = "re", vline.color="grey", dot.size=1.1, value.size=3,
           show.values=T, value.offset=.3) + 
        labs(x='Year', y='Value', title='Random effects: Slope - Model 2') + 
        xlim(factor(year_list_2000))
```

This is mathematically represented by:

$$
  \log(\text{PPMR})_{ij} = \beta_{0} + 
        (\beta_{1} + \alpha_{1y}) \log(\text{predator mass})_{i} + \epsilon_{iy}
$$

Where:

* $i$ is the index of the individual observation
* $y$ is the index of the year
* $\beta_{0}$ is the overall intercept term
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)
* $\alpha_{1y}$ is the slope term that's dependent on the random effect (the year)
(where $\alpha_{1y}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{A[10]}$ (i.e. $\alpha_{1y} \sim (0, \sigma^2_{A[10]})$)).
* $\epsilon_{iy}$ is the error term, which describes the residuals of the model

For this plot, the value of log(predator mass) is modelled to be dependent on the year that each observation is taken. This allows us to have lines for each unique year which all have the same intercept but differing slopes.

### Third trial

Fixed effects: $\log$(predator mass)

Random effects: year (random slope and random intercept)

```{r third}
three <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|year), data = renamed_df, REML=FALSE)
#Random intercept and random slope (correlated)

plot_model(three, type = "re", vline.color="grey", dot.size=1.1, value.size=3,
           show.values=T, value.offset=.3) + 
        labs(x='Year', y='Value', title='Random effects - Model 3') + 
        xlim(factor(year_list_2000))
```

This is mathematically represented by:
$$
  \log(\text{PPMR})_{ij} = (\beta_{0} + \alpha_{0j}) + 
        (\beta_{1} + \alpha_{1j}) \log(\text{predator mass})_{i} + \epsilon_{ij}
$$

Where:

* $i$ is the index of the individual observation
* $y$ is the index of the year
* $\beta_{0}$ is the overall intercept term
* $\alpha_{0j}$ is the random intercept term for predator species $j$
(where $\alpha_{0y}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{A[00]}$ (i.e. $\alpha_{0y} \sim (0, \sigma^2_{A[00]})$)).
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)
* $\alpha_{1y}$ is the slope term that's dependent on the random effect (the year)
* $\epsilon_{iy}$ is the error term, which describes the residuals of the model

From the table, we can see this model features slopes and intercepts that are different for each year are different.

### Comparing the models

```{r forming models}
anova(one,two,three)
#comparing the three models
```

We can see that the third trial has a significantly smaller BIC value, and hence we will choose to continue using models which have slopes and intercepts that vary according to the fixed effect.

## Trialing different models - only for Mackerel {.tabset}

Here, all the random effects are modeled with a randomly distributed slope and intercept for each level of a grouping.

### With ship name

```{r trial a}
mackerel_df <-  renamed_df %>% filter(pred_species == fixed("Mackerel"))

a <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short), data = mackerel_df, REML=FALSE)

summary(a)

qqnorm(resid(a))
qqline(resid(a))
#look for lying along the line

mackerel_df %>% 
  ggplot(aes(x = resid(a))) +
  geom_density(colour="blue") +
  labs(title='Density plot of the residuals for model a: Mackerel', x='Residuals', y='Density')

#resid(a) gives the residuals of model a
#The residuals are found by subtracting the fitted from the predicted values
```

This is mathematically represented by:

$$  
\log(\text{PPMR})_{ih} = (\beta_{0} + H_{0h}) + 
        (\beta_{1} + H_{1h}) \log(\text{predator mass})_{i} + \epsilon_{ih}
$$

Where:

* $i$ is the index of the individual observation
* $h$ is the index of the different haul_id name
* $\beta_{0}$ is the overall intercept term
* $H_{0h}$ is the random intercept term for haul_id $h$
(where $H_{0h}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{H[00]}$ (i.e. $H_{0h} \sim (0, \sigma^2_{H[00]})$)).
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)
* $H_{1h}$ is the slope term that's dependent on the random effect (the haul_id)
* $\epsilon_{ih}$ is the error term, which describes the residuals of each point

And:

* Fixed effects: $\log$(predator mass)
* Random effects: ship name

### With year

```{r trial b}
b <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short) + (1+lpred_weight|year), 
          data = mackerel_df, REML=FALSE)

summary(b)

qqnorm(resid(b))
qqline(resid(b))
#look for lying along the line

mackerel_df %>% 
  ggplot(aes(x = resid(b))) +
  geom_density(colour="red") +
  labs(title='Density plot of the residuals for model b: Mackerel', x='Residuals', y='Density')
```

Mathematical representation
$$  
  \log(\text{PPMR})_{ihy} = (\beta_{0} + H_{0h} + Y_{0y}) +
        (\beta_{1} + H_{1h} + Y_{1y}) \log(\text{predator mass})_{i} + \epsilon_{ihyr}
$$

Where:

* $y$ is the index of the different year the observation was taken
* $Y_{0y}$ is the random intercept term for haul_id $h$
(where $Y_{0y}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{Y[00]}$ (i.e. $Y_{0y} \sim (0, \sigma^2_{Y[00]})$)).
* $Y_{1y}$ is the slope term that's dependent on the random effect (the haul_id)

And:

* Fixed effects: $\log$(predator mass)
* Random effects: ship name, year



### With location

```{r trial c}
c <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|haul_id_short) + (1+lpred_weight|year) +
            (1+lpred_weight|ices_rectangle), data = mackerel_df, REML=FALSE)

summary(c)

qqnorm(resid(c))
qqline(resid(c))
#look for lying along the line

mackerel_df %>% 
  ggplot(aes(x = resid(c))) +
  geom_density(colour="green") +
  labs(title='Density plot of the residuals for model c: Mackerel', x='Residuals', y='Density')
```

Mathematical representation:
$$  
  \log(\text{PPMR})_{ihyr} = (\beta_{0} + H_{0h} + Y_{0y} + R_{0r} )+
        (\beta_{1} + H_{1h} + Y_{1y} + R_{1r}) \log(\text{predator mass})_{i} + \epsilon_{ihyr}
$$

Where:

* $r$ is the index of the different ices_rectangle term
* $R_{0r}$ is the random intercept term for the ices_rectangle $r$
(where $R_{0r}$ is normally distributed with a mean of $0$ and a standard deviation $\sigma_{R[00]}$ (i.e. $R_{0r} \sim (0, \sigma^2_{R[00]})$)).
* $R_{1r}$ is the slope term that's dependent on the random effect (the haul_id)

And:

* Fixed effects: $\log$(predator mass)
* Random effects: ship name, year, ices_rectangle

### Comparing

```{r comparisons}
ggplot(data=mackerel_df) +
  labs(title='Density plot of the residuals: Mackerel', x='Residuals', y='Density', 
       color="Model", linetype="Model") +
  geom_density(aes(x=resid(a), colour="with ship name", linetype="with ship name")) +
  geom_density(aes(x=resid(b), colour="with ship name and year", 
                  linetype="with ship name and year")) +
  geom_density(aes(x=resid(c), colour="with ship name, year and location", 
                   linetype="with ship name, year and location")) +
  scale_color_manual(values=c("blue", "red", "green")) +
  scale_linetype_manual(values = c("dashed", "dotted", "dotdash")) +
  theme_classic()

anova(a,b,c)
#comparing the three models
```

The BIC value is the smallest when all three random effects are considered, and the residuals for this three-random-effect model look the most similar to a normal distribution. Therefore, we will choose to use a model which uses all three random effects for further analysis. 

## Mixed effects model - over all species

The third model (with ship name, year and location as random effects) appears to represent the data the most effectively. We now want to consider a mixed effects model over all the predator species (not just Herring). Therefore, we choose to continue with model c (with random effects:ship name, year, ices_rectangle), but we also introduce a fourth random effect of predator species.

Mathematical representation:
$$
  \log(\text{PPMR})_{ihyrp} = (\beta_{0} + H_{0h} + Y_{0y} + R_{0r}) +
        (\beta_{1} + H_{1h} + Y_{1y} + R_{1r}) \log(\text{predator mass})_i + \\
        \sum_{p=1}^{16} \alpha_p (\text{predator species})_p +
        \epsilon_{ihyr}
$$
Where:

* $i$ is the index of the individual observation
* $h$ is the index of the different ship name
* $y$ is the index of the the year each observation is taken
* $r$ is the index of the different ices_rectangle term
* $p$ is the index of the predator species the observation belongs to
* $\beta_{0}$ is the overall intercept term
* $H_{0h}$ is the random intercept term for haul_id, $h$
* $Y_{0y}$ is the random intercept term for year, $y$
* $R_{0r}$ is the random intercept term for ices_rectangle, $r$
* $\beta_{1}$ is the slope term that's dependent on the fixed effect (the predator mass)
* $H_{1h}$ is the slope term that's dependent on the haul_id
* $Y_{1y}$ is the slope term that's dependent on the year
* $R_{1r}$ is the slope term that's dependent on the ices_rectangle
* $\alpha_p$ is the slope term which is dependent on the predator species (and each predator species $p$ has a unique slope term)
* $\epsilon_{ihyr}$ is the error term, which describes the residuals of each point

(where each random intercept term and the residuals are normally distributed with a mean of $0$ and a standard deviation $\sigma_{[00]}$ (i.e. $sim (0, \sigma^2_{[00]})$)).

and,

$$
    \text{species} = \{\text{Blue Whiting}, \text{ Cod}, \text{ Common Dab}, \text{ European Hake}, \ldots, \text{ Whiting}\}
$$

is an array containing all possible predator species types, so:

$$
    \text{pred}_p = 
    \begin{cases}
        1, \text{if the species that observation i belongs to is } \text{species}[p] \\
        0, \text{ otherwise}
    \end{cases}
$$

So, 

* Fixed effects: $\log$(predator mass), predator species
* Random effects: ship name, year, ices_rectangle

```{r final model}
 final <- lmer(lppmr ~ lpred_weight + pred_species + 
            (1+lpred_weight|haul_id_short) + (1+lpred_weight|year) +
            (1+lpred_weight|ices_rectangle), 
            data = renamed_df, REML=FALSE)

summary(final)

qqnorm(resid(final))
qqline(resid(final))
#look for lying along the line

renamed_df %>% 
  ggplot(aes(x = resid(final))) +
  geom_density(aes(linetype="line", color="line")) +
  labs(title='Density plot of the residuals', x='Residuals', y='Density', 
              color="Line", linetype="Line") +
  stat_function(fun = dnorm, aes(linetype = "normal", color="normal"),
              args= with(final, c(mean = mean(resid(final)), sd(resid(final))))) +
  scale_color_manual(values=c('red', 'black')) +
  scale_linetype_manual(values = c("solid", "dashed"))
```

This model has the following variables:

Variable name |  Meaning            | Value   
------------- | -----------         | ---------    
$\beta_{0}$   | the intercept term  |  5.0363484
$\beta_{1}$   | the fixed effect (slope) for $\log(\text{predator mass})$ | 0.2737651
$\sigma_{H[0h]}$ |  s.d. for the intercept term $H_{0h}$, dependent on the haul_id_short | 1.6247
$\sigma_{H[1h]}$ |  s.d. for the slope term $H_{1h}$, dependent on the haul_id_short | 0.2509
$\sigma_{Y[0y]}$ |  s.d. for the intercept term $Y_{0y}$, dependent on the year | 1.0074
$\sigma_{Y[1y]}$ |  s.d. for the slope term $Y_{1y}$, dependent on the year|  0.1194
$\sigma_{R[0r]}$ |  s.d. for the intercept term $R_{0r}$, dependent on the ices_rectangle | 0.8934
$\sigma_{R[1r]}$ |  s.d. for the slope term $R_{1r}$, dependent on the ices_rectangle | 0.1545
$\sigma_{\epsilon[ihyr]}$ | the s.d. of the residual/error term | 1.8944

## Separated by predator species {.tabset}

Separating the plots out over the predator species provides the following information:

### Slope values

```{r}
new <- coef(summary(final))[3:17]

pred_lmer <- data.frame(Species=c(species_list[2:16]),
                        "Gradient"=c(new))

kable(pred_lmer)

#BLUE WHITING??
```

### Density of residuals

```{r}
renamed_df %>% 
  ggplot(aes(x = resid(final), color=pred_species)) +
  geom_density() +
  labs(title='Density plot of the residuals - separated over species',
              x='Residuals', y='Density') +
  facet_wrap(~pred_species) +
  theme(legend.position="none")
```

## Comparisons for Mackerel {.tabset}

### Distribution of prey types
```{r}
mackerel_df <-  renamed_df %>% filter(pred_species == fixed("Mackerel"))

ggplot(mackerel_df, aes(x=prey_type, fill=prey_type)) +
   geom_bar_pattern(stat = "count",
                    pattern_color = "white",
                    pattern_fill = "black",
                    aes(pattern = prey_type, pattern_angle = prey_type)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="none") +
  labs(x="Prey type", y="Number of Observations")
```

### Density of lppmr observations
```{r}
ggplot(mackerel_df, aes(x=lppmr)) +
  geom_density(aes(weight = no._prey_per_stmch), color="lightseagreen") +
  labs(x="log(PPMR)", y="Number density of observations")
```

### Density plot of the residuals 
```{r}
mackerel_df %>% 
  ggplot(aes(x = resid(c))) +
  geom_density(colour="lightseagreen") +
  labs(x='Residuals', y='Density') +
  theme_classic()
```



