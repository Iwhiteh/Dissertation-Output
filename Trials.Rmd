---
title: "Dissertation"
author: "Imogen Whitehead"
output:
  html_document:
    number_sections: yes
    code_folding: hide
    theme: cerulean
    toc: yes
---

```{r setup, echo=TRUE, message=FALSE}
#number_sections: yes
    #code_folding: hide
    #theme: cerulean
#html_document:

#message=FALSE means some output messages aren't printed in the knitted HTML document

knitr::opts_chunk$set(echo = FALSE, warning=FALSE) 
#include=FALSE, echo=FALSE and warning=FALSE ensure the code and any error messages aren't shown in the output HTML file

#message=FALSE means no output messages are printed on the knitted HMTL file
#loading any necessary packages
library(dplyr)
library(tidyverse) 
library(knitr)
library(readr)
library(ggplot2)
library(bbmle)
library(mizer) 
library(Hmisc)
library(lme4)
library(RColorBrewer)
library(viridis)
library(hexbin)
```

```{r loading, message=FALSE, echo=TRUE}
load("stomach_dataset.Rdata")
#loading the dataset to be used in analysis (the dataset is already named stom_df)

df <- stom_df %>% transmute(haul_id, ices_rectangle, year, pred_species, 
                            pred_weight_g, pred_length_cm, prey_weight_g, 
                            prey_type = prey_funcgrp, indiv_prey_weight = prey_ind_weight_g, 
                            prey_count, n_stomachs, no._prey_per_stmch = prey_count/n_stomachs, ppmr) 
#creating a new data set called 'df' which only contains certain selected columns

df <- df[df$indiv_prey_weight != 0, ]
df <- df[df$pred_weight_g != 0, ]
df <- df[df$indiv_prey_weight != Inf, ]
#Removes any points where the prey weight = Inf or 0, or the predator weight = 0
```

```{r cleaning smaller, message=FALSE, echo=TRUE}
renamed_df = df %>% 
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Micromesistius poutassou", "Blue Whiting")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Gadus morhua", "Cod")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Limanda limanda", "Common Dab")) %>%
  mutate(pred_species = replace(pred_species, 
                                pred_species == "Merluccius merluccius", "European Hake")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Melanogrammus aeglefinus", "Haddock")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Clupea harengus", "Herring")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trachurus trachurus", "Horse Mackerel")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Scomber scombrus", "Mackerel")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lepidorhombus whiffiagonis", "Megrim")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Lophius piscatorius", "Monkfish")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus esmarkii", "Norway Pout")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Pleuronectes platessa", "Plaice")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Trisopterus minutus", "Poor Cod")) %>%  
  mutate(pred_species = replace(pred_species, pred_species == "Solea solea", "Sole")) %>% 
  mutate(pred_species = replace(pred_species, pred_species == "Sprattus sprattus", "Sprat")) %>%
  mutate(pred_species = replace(pred_species, pred_species == "Merlangius merlangus", "Whiting"))
#Renaming the predator species from their latin names (e.g. Capros apers) to their more common names (e.g. Boarfish)
#Creates a new data frame (called 'renamed_df') with these replaced names

species_list <- c("Blue Whiting", "Cod", "Common Dab", "European Hake", "Haddock", "Herring",
                     "Horse Mackerel", "Mackerel", "Megrim", "Monkfish", "Norway Pout",  "Plaice",
                     "Poor Cod", "Sole", "Sprat", "Whiting")
#Creates an array called 'species_list', which is list of the predator species we are focusing on in this project

renamed_df <- renamed_df[renamed_df$pred_species %in% species_list, ]
#Removes any observations of predator species not in the species_list, i.e. they are irrelevant data points for this project

renamed_df$lppmr <- log(renamed_df$ppmr)
renamed_df$lprey_weight <- log(renamed_df$indiv_prey_weight)
renamed_df$lpred_weight <- log(renamed_df$pred_weight_g)
#Adds columns which take the log value of ppmr, individual prey weight and predator weight to the main data set
```

# Introduction

This data set is formed from recordings taken by multiple ships between the years 1886-2016.

Fish were taken from some location, and their individual stomach contents recorded. Predators of the same species and (roughly) the same weight/size were recorded as a single data point (the number of predators for each data set is called 'n_stomachs'). Prey of (roughly) the same size found in these stomachs were recorded in this same data point, and the total number of prey in some data point is called 'prey_count'. For each individual data point,

$$
    \text{no. prey per stomach} = \frac{\text{no. of stomachs sampled}}{\text{total no. of prey}}
$$
This is an approximation of the number of prey per stomach for some specific predator, and is called '
no._prey_per_stmch'.

Using similar logic,'prey_weight_g' is the total weight of prey in the multiple stomachs sampled to make up one datapoint. 'indiv_prey_weight' is then the weight of one single prey individual found in the stomach


There are some other column names which are useful to note:

* ices_rectangle accounts for location of points, where each area the points are sampled in is split up into a number of smaller rectangles and each is given a unique name
* ppmr stands for 'predator prey mass ratio', and is calculated by:
* haul_id is a identification tag given to each individual ship which recorded observations

# Distribution of prey type eaten for each predator

```{r distribution of prey, echo=TRUE}
ggplot(renamed_df, aes(x=prey_type, fill=prey_type)) +
  geom_bar(stat="count", width=0.7) +
  facet_wrap(~renamed_df$pred_species, scale="free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_brewer(palette = "Dark2", name = "Prey Type") +
  labs(title = "Distribution of prey types for each predator species", x="Prey type",
       y="Number of Observations")

#geom_bar() creates a bar chart from the specified data
#facet_wrap() means an individual bar chart is created for each individual predator species
#'theme()' adjusts the labels along the x-axis so they lie slightly angled to the vertical direction so they are easy to read
#scale_fill_brewer changes the colour palette of the plot so that the colours are easy to distinguish between, and renames the title of the key to show which colour means what
```

These are individual bar charts showing the distribution of the type of prey each predator eats.

The prey types are:

* Benthos: organisms that live on/near the bottom of a body of water
* Fish: aquatic, craniate (have a skull), gill-bearing animals that lack limbs with digits (i.e. their limbs don't have toes or fingers)
* Nekton: the actively swimming aquatic organisms
* Other: misc. types that don't fit into the other categories
* Zooplankton: animal plankton (plankton are aquatic organisms that are unable to swim effectively against currents)

We can see that some predators eat a range of prey types (e.g. Whiting), while others prefer to eat a single prey type in abundance (e.g. European Hake and Monkfish mostly consume fish as their prey).

# Most common prey weights
```{r log(prey weight) v. number of prey per stomach, echo=TRUE}
ggplot(data = renamed_df, aes(lprey_weight, no._prey_per_stmch)) + 
      labs(title = "Number of prey per predator stomach v. log(prey weight) ", 
       x="log(prey weight)", y="Number of prey per predator stomach") + 
      geom_point(size=0.5)

#geom_point() adds individual points which show individual recorded points
#size=0.5 defines the size of each point on this graph
``` 

This graph is looking at the distribution of the weight of prey recorded, i.e. looking at what is the most common prey weight over all prey species. It is a graph over all the data points, so includes recordings from all the ships involved.

There are some potentially interesting results, so results from different ships were plotted on individual curves to further look into these results.

```{r sep by ships, echo=TRUE}
renamed_df$'haul_id_short' <- gsub("\\-.*", "", renamed_df$'haul_id')
renamed_df$'haul_id_short' <- gsub("_", "", renamed_df$'haul_id_short')
#the haul_id values are renamed to be shortened versions of the ship names (e.g. CLYDE) rather than the complete id (e.g. CLYDE-1935-6)

interesting_haul <- filter(renamed_df, 
                           haul_id_short=='CLYDE'|haul_id_short=='END04'|haul_id_short=='LUC'|
                             haul_id_short=='HIDDINK'|haul_id_short=='EXCmacDATSTO815'|
                             haul_id_short=="Excmacdatsto815error")
#interesting_haul is a new data frame which only contains values recorded by ships which gave "interesting" looking datapoints

haul_list_interesting <- unique(interesting_haul$haul_id_short)
#creates an array containing every individual (renamed) ship name that we are interested in

ggplot (data = interesting_haul, aes(x=lprey_weight, y=no._prey_per_stmch)) + 
  labs(title = "Number of prey per stomach v. log(prey weight) - separated by ship names",
       x="log(prey weight)", y="Number of prey per stomach") + 
  geom_point(size=0.02, colour="red") +
  theme(strip.text = element_text(size = 10)) + 
  facet_wrap(~interesting_haul$haul_id_short, scale="free_y")
```

These six graphs show a range of unusual looking points:

1. $y \propto e^{-x}$ relation for END04 (i.e. no. per stomach is proportional to 1/prey weight)
2. lots of observations for single prey weights for LUC and CLYDE (554)
3. lots of the same no. of prey per stomach observations for HIDDINK.(27180)
4. the EXCmacDATSTO815 and Excmacdatsto815error seem to represent exactly the same data

There are a number of other graphs which also provided potentially erroneous data, and the number of datapoints affected are as below:

```{r no of obs, echo=TRUE}
paste("Number of observations of type 1:", count(filter(renamed_df, haul_id_short=='END04')))

paste("Number of observations of type 2:", count(filter(renamed_df, haul_id_short=='CLION09'|haul_id_short=='LUC'|haul_id_short=='UNITY'|haul_id_short=='CLYDE')))

paste("Number of observations of type 3:", count(filter(renamed_df, haul_id_short=='BEAVER'|haul_id_short=='BRUCELLA'|haul_id_short=='BULLEN'|haul_id_short=='CIROL04'|haul_id_short=='CIROL10'|haul_id_short=='CLION03'|haul_id_short=='CLION07'|haul_id_short=='CLION12'|haul_id_short=='COREL02'|haul_id_short=='COREL06'|haul_id_short=='CORY04'|haul_id_short=='CYPRIS'|haul_id_short=='END02'|haul_id_short=='END12'|haul_id_short=='HEINCKE147'|haul_id_short=='HIDDINK'|haul_id_short=='OITHONA'|haul_id_short=='STRANDLINE'|haul_id_short=='TELLINA')))

paste("Number of observations of type 4:", count(filter(renamed_df, haul_id_short=='EXCmacDATSTO815'|haul_id_short=='Excmacdatsto815error')))
```

Though we will not remove or alter the data set to account for these potentially erroneous data points in this project, for further analysis it may be sensible to remove the data points these six ships recorded so that final analysis is as reliable as possible.

# Prey and predator weight relation

We are attempting to find a link between the predator mass and the prey mass. Log() of each axis is used to see the proportionality of the axes, where the slope of the added line should = 1. This is because:

$$
 \log (\text{prey mass}) = m \times \text{log(predator mass)} + c ,
$$

where m is the gradient of the slope and c is the y-intercept (thinking of this graph as a linear model).

Taking the exponential of both sides,

$$
  \text{prey mass} = \exp({{m}\times{\log(\text{predator mass})}}) + \log(D) ,
$$
where log(D) = c. 

Finally,

$$
  \text{prey mass} = \text{predator mass}^m \times D
$$

Hence, we want m=1 to show that log(predator mass) is proportional to log(prey weight) (as expected).

```{r log(prey weight) v. log(pred weight), echo=TRUE, message=FALSE}
#message=FALSE means some output messages aren't printed in the knitted HTML document

ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey mass) v. log(predator mass) plot", 
       x="log(predator mass)", y="log(prey mass)") + 
  geom_hex(bins = 50) +
  scale_fill_gradient2(low = "black", mid="orange", high = "red", midpoint=600) +
  stat_smooth(method='lm', se=FALSE, colour="blue")

# stat_smooth adds a line of best fit plotted through the points
# method='lm' ensures it is a straight line, i.e. a linear model
# se=FAlSE creates only a single line, with no error of margin included

#geom_hex creates "bins" in the data where the density is calculated over
#bins=50 means that there are 50 "bins" in the horizontal direction and 50 in the vertical
#scale_fill_gradient2 creates a density colour scale, meaning that areas with a high density of points are red and areas with a low density of points are darker in colour

slope <- coef(lm(renamed_df$lprey_weight~renamed_df$lpred_weight))
paste("slope of the log(prey mass) v. log(predator mass) line of best fit:", slope[2])

# coef(lm()) creates an array containing the coefficients of the linear model of the relationship between two axes
# The first item of the array gives out the y-intercept of the line, and the second item of the array is the gradient
```

For this graph, the slope is not equal to one. However, this graph is plotted over the entire data set and includes values from all of the available predator species.

Instead, separate the plots by predator species to see if there is some proportionality between the predator and prey weight for each specific species.

## Prey v. predator mass plot, separated by predator species

```{r sep by pred species, echo=TRUE, message=FALSE}
ggplot(data = renamed_df, aes(lpred_weight, lprey_weight)) + 
  labs(title = "log(prey mass) v. log(predator mass), separated by predator species", 
       x="log(predator mass)", y="log(prey mass)") +
  geom_point(size=0.2) + 
  facet_wrap(~pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 10)) +
  stat_smooth (method='lm', se=FALSE, colour="red")
```

## Gradients of the plots for each predator species

```{r pvp gradients, echo=TRUE}
i <- 1
species_grad = c()
#setting i=1 for the while loop
#and creating an empty vector called 'species_grad' to hold data

while(i<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[i]))
  grad <- coef(lm((species_df$lprey_weight)~(species_df$lpred_weight)))
  species_grad[i] <- grad[2]
  i=i+1
}

#'while' means that this function repeats through the length of 'species_list' until all predator species are accounted for
#i=i+1 increases the value of i each time through this loop to motivate this repeat
#this creates a data frame (species_df) containing each indivdual predator species, then calculates the gradient of the log(pred weight) v. log(prey weight) graph for this individual predator species, then inserts this gradient value to the ith value of an array named 'species_grad'

pvp_grads <- data.frame("Predator Species"=c(species_list),
                        Gradient=c(species_grad))

kable(pvp_grads)
#creates a new data frame name 'pvp_grads', with one column named 'pred_species' and the other named 'gradient'
#each row contains the name of some individual predator species and its associated gradient
#kable prints the information in the pvp_grads
```

Here, we are splitting up the graphs over each individual predator species to look and see if there is a proportionality for each specific species.

We are wanting gradient=1 for proportionality. This is only true (to 1 significant figure) for the species Cod, European Hake, Monkfish and Whiting. Although this is a very limited number of the predator species, the assumption that the predator and prey masses are proportional is a reasonable one, so we will continue wiht this assumption.

# Specific PPMR calculations by different weightings for Herring species

Here, we take only observations relating to the predator type Herring. This allows us to do more specific analysis about the shifted mean and begin to explain the maths behind this shifting.

```{r Herring PPMR setup, echo=TRUE}
herringDF <- renamed_df %>% 
    filter(pred_species == fixed("Herring"))
#creates a separate data set (called 'herringDF') only containing observations for the predator species 'Herring'
```

## Weighted by prey biomass

```{r Prey biomass weighting, echo=TRUE} 
bio_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE)
bio_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$prey_weight_g, na.rm = TRUE))

#weighted.mean gives the arithmetic mean of log(ppmr), where datapoints are weighted by the prey weight of observations
#similarly, wtd.var is the variance of log(ppmr), where the datapoints are also weighted by the prey weight
#standard deviation is defined as the square root of the variance
#na.rm=TRUE means any rows with missing values (values that equal 'na') aren't included in the mean/variance calculations, but are instead ignored

ggplot(data = herringDF, aes(x=lppmr)) + 
          labs(title = "Density plot of log(ppmr) for Herring,
               weighted by prey biomass", 
               x="log(PPMR)",y="Biomass density of observations") +
          geom_density(aes(weight = prey_weight_g), colour="red") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) + 
          stat_function(fun = dnorm, 
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD))) +
          xlim(-5,17)

#axis.text.y adjusts the size of the axis labels on the y-axis so they are most easily readable
#stat_function adds a normal distribution curve (fun=dnorm) with a mean and standard deviation equal to what was calculated earlier for this data set
#xlim sets limits for the x-axis so that all the necessary data points can be seen

paste("Mean value of log(ppmr), weighted by biomass of prey:", bio_herringmean)
paste("Standard deviation of this:", bio_herringSD)
```

The curve with points weighted by the prey biomass is plotted in blue, and a normal curve (also weighted by prey biomasss) is plotted over the top in black.

## Weighted by number of prey

```{r No of prey weighting, echo=TRUE} 
no_herringmean = weighted.mean(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE)
no_herringSD = sqrt(wtd.var(herringDF$lppmr, w = herringDF$no._prey_per_stmch, na.rm = TRUE))
#the mean and variance are both weighted by the number of prey

ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(ppmr) for Herring, 
               weighted by no. of prey",
               x="log(PPMR)", y="No. density of observations") +
          geom_density(aes(weight = no._prey_per_stmch), colour="green") + 
          theme(plot.title = element_text(size=15), axis.text.y = element_text(size=10)) +
          stat_function(fun = dnorm, 
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD))) +
          xlim(0,25)

#the xlim is different to the graph above because these data points lie over a slightly different log(ppmr) range

paste("Mean value of log(ppmr), weighted by number of observations:", no_herringmean)
paste("Standard deviation of this:", no_herringSD)
```

The curve with points weighted by the number of prey per stomach is plotted in red, and a normal curve (also weighted by the number of prey per stomach) is plotted over the top in black.

## Combined graph

```{r Herring combined graph, echo=TRUE} 
ggplot(data = herringDF, aes(x=lppmr), group=1) + 
          labs(title = "Density plot of log(ppmr) for Herring,
               with various weightings",
               x="log(PPMR)", y="Number/biomass density of observations") +
          geom_density(aes(weight = no._prey_per_stmch, colour="prey biomass")) + 
          geom_density(aes(weight = prey_weight_g, colour="number of prey per stomach")) + 
          stat_function(fun = dnorm, 
                        args= with(herringDF, c(mean = no_herringmean, sd = no_herringSD))) +
          stat_function(fun = dnorm, 
                        args= with(herringDF, c(mean = bio_herringmean, sd = bio_herringSD))) +
          theme(plot.title = element_text(size=15)) +
          scale_color_manual(name='Weightings', values=c('green', 'red')) +
          xlim(-5,25) 

#scale_color_manual manually adds a key to the graph to describe what the differently coloured lines represent
#each curve is given a name using 'aes(colour="")', and these are then given a specific colour using 'values='
```

This is a graph with both the the distribution of Herring log(PPMR) as weighted by prey biomass and number of prey plotted over each other (along with appropriately weighted normal distribution curves plotted over the top of each).

Prey biomass weighted mean: 6.629177
No. of prey weighted mean: 13.54102

Prey biomass standard deviation: 2.3508789268221
No. of prey standard deviation: 2.63330496940788

The mean is shifted by 6.911843.

The mathematics of shifted means for this difference in weighting is:

$$
  \text{weighted mean}_{\text{expected prey biomass}} = \text{weighted mean}_{\text{no. of prey }} - (\text{standard deviation}_{\text{no. of prey }})^2
$$

Hence, the expected result is:

$$
  \text{weighted mean}_{\text{actual prey biomass}} = 13.54102 - (2.63330496940788)^2 = 6.60672493809
$$

There is a difference in expected and actual prey biomass weighted mean of 0.30511806191. This is a fairly insignificant value, which suggests the shifting mean equations are relatively accurate for this data set with these weightings.

Therefore, we can continue with the assumption that there is a difference in the mean of log(ppmr) of the square of the standard deviation when we weight by number of prey per stomach and prey biomass.

# Predator mass against ppmr

## Plotting ppmr against predator mass, separated by predator species

```{r pred mass v. ppmr, echo=TRUE, message=FALSE}
ggplot(data=renamed_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.001) +
  labs(title = "log(PPMR) v. log(predator mass) plot", x="log(Pred mass)", y="log(PPMR)") + 
  stat_smooth (method='lm', se=FALSE) + 
  facet_wrap(~pred_species, scale="free_y")
```

Graphing $\log$(pred mass) v. $\log$(PPMR) for individual predator species to see if the predator mass related to the ppmr. 

$$
    \log(\text{PPMR}) = m \times \log (\text{pred mass}) + c
$$

where m is the gradient (assuming a linear model between the variables) and c is the y-intercept. 

We want them to not be proportional (i.e. slope,  m= 0) to prove that log(predator mass) is not related to the log(ppmr). This would mean that the ppmr is independent of the predator mass for a certain species (as assumed).

## Gradients of the plots

```{r ppmrvp gradients, echo=TRUE}
species_grad_ppmr=c()
j <- 1
#creates an empty vector called 'species_grad_ppmr'
#setting j=1 for the while loop

while(j<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[j]))
  grad <- coef(lm((species_df$lppmr)~(species_df$lpred_weight)))
  species_grad_ppmr[j] <- grad[2]
  j=j+1
}

ppmrvp_grads <- data.frame(pred_species=c(species_list),
                        gradient=c(species_grad_ppmr))

kable(ppmrvp_grads)
```

For the assumption to be upheld, we need gradient=0. This is (approximately) satisfied for the species Cod, Common Dab, Euorpean Hake, Haddock, Megrim, Monkfish, Norway Pout and Poor Cod. Although none of these are exactly equal to 0, they are sufficiently close to continue with the assumption that the ppmr is independent of the predator mass for the named predator species.

## Residuals of the lppmr v. lpred mass

```{r residual plot, echo=TRUE, message=FALSE}
species_df2 <- renamed_df %>% filter(pred_species == fixed("Herring"))
model2 <- lm(lppmr ~ lpred_weight, data=species_df2) 
res <- resid(model2)

#lm() fits a regression models for log(ppmr) against log(predator mass)
#resid() creates a list of the residual of each individual data point

#abc <- ggplot(species_df2, aes(x = lpred_weight, y = lppmr)) +
#  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +     
#  geom_segment(aes(xend = lpred_weight, yend = res), alpha = .2,  colour = "blue") +
#  geom_point(size=0.5)

#plot(fitted(abc),res) + abline(0,0)

# geom_smooth() creates the regression line of the regression model from lm()
# geom_segment() draws a line from each point to the regressionline 

#plot(fitted(model), res) + abline(0,0)

#this plots the residuals of each data point, and adds a line across at res=0 to help visualise the data

#hist(resid(model), border='red', col="transparent", 
#       main = paste("Histogram of residuals: Herring"))
#hist(resid()) plots a histogram of the residuals of each lppmr v lpred_weight graph
```

We can see that for Herring, the residuals do not particularly look like they are normally distributed.


```{r applying residual plots, echo=TRUE, message=FALSE}
i <- 1
#setting i=1 for the while loop

while(i<=length(species_list)){
  species_df <- renamed_df %>% filter(pred_species == fixed(species_list[i]))
  model <- lm(lppmr~lpred_weight, data=species_df)  
  hist(resid(model), border='red', col="transparent", 
       main = paste("Histogram of residuals:", species_list[i] ))
  i=i+1
}
```

This is a histogram plot of the residuals of the plot, separated for each predator species. We are looking for residuals which are normally distributed around resid=0. 

Of the resulting histograms, the following show (approximately) a normal distribution:
  * Cod
  * European Hake
  * Megrim
  * Monkfish
  * Norway Pout
  * Poor Cod
  * Whiting
  
Therefore, the assumption that the gradient of the lppmr v lpred_weight graph is equal to 0 for each plot (approximately) holds true for the above species.

## Different weightings

```{r poor cod, echo=TRUE, message=FALSE}
species_df <- renamed_df %>% filter(pred_species == fixed("Poor Cod"))
#creating a data frame only containing observations where the predator species is poor cod.

ggplot(data=species_df, aes(lpred_weight, lppmr)) + 
  geom_point(size=0.5) +
  labs(title = "log(PPMR) v. log(predator mass) plot: Poor Cod", 
       x="log(Pred mass)", y="log(PPMR)") + 
  facet_wrap(~pred_species, scale="free_y") + 
  stat_smooth(aes(weight=no._prey_per_stmch, colour='by no. of prey in stomach'), 
              method='lm', se=FALSE) +
  stat_smooth(aes(colour='no weighting'), method='lm', se=FALSE) +
  stat_smooth(aes(weight=prey_weight_g, colour='by prey bio'), method='lm', se=FALSE) +
  stat_summary(fun.data=mean_se, geom="linerange") +
  scale_colour_manual(name="Weightings",
                     values=c('by no. of prey in stomach'='green', 
                              'no weighting'='blue', 'by prey bio'='red'))
# se=FALSE doesn't add an area of error around the LOBF 
# fun.data=mean_se calculates the mean and standard error for each point
# linerange draws a point range between an upper and lower limit for the line, and the mean for the point (using the values calcuated in 'fun.data=mean_se')

paste("slope of the log(ppmr) v. log(predator weight) line of best fit for poor cod:")

#weighted by number of prey per stomach
perstmch_weighting <- 
  coef(lm(species_df$lppmr~species_df$lpred_weight, weight=species_df$no._prey_per_stmch))
paste("i) Weighted by no prey in the stomach:", perstmch_weighting[2])

#no weighting
no_weighting <- coef(lm(species_df$lppmr~species_df$lpred_weight))
paste("ii) No weighting in the calculation:", no_weighting[2])

#weighted by prey biomass
biomass_weighting <- 
  coef(lm(species_df$lppmr~species_df$lpred_weight, weight=species_df$prey_weight_g))
paste("iii) Weighted by prey biomass:", biomass_weighting[2])
```


Looking at just the predator species 'poor cod'. There are three LOBF (line of best fit), weighted by different variables:

1. blue: by number of prey per stomach
2. red: no weighting in the LOBF
3. green: by prey biomass

When weighted by prey biomass, the gradient is equal to zero for 2 s.f.. Hence, the approximation (of slope=0) is true when looking at a prey biomass weighting.

# Average PPMR for individual species

Here, we are looking for the most common log(PPMR) for each individual species. This will be done by plotting log(PPMR) against the density of points, and weighting observations on different variables. By assuming these are normally distributed relations, there should be a 'peak' point of log(ppmr) which is where the mean/most common log(ppmr) value lies. We assume this will be different for different species of predator, i.e. each predator has a preferred ppmr value and hence each predator type has a preferred relative size of prey.

##  Weighted by prey biomass
```{r ave PPMR biomass, echo=TRUE}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by biomass density of prey", 
       x="log(PPMR)", y="Biomass density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = prey_weight_g), colour="red")

#using facet_wrap for the variable (pred_species) means the data is separated into individual plots for each predator species
#geom_density means area under the curve = 1 (i.e. the graph is normalised)
#weight=prey_weight_g means the points are 'weighted' by the column weight (biomass) of each individual prey
``` 

These plots are weighted by the prey biomass. This means that we are looking at the distribution of prey biomass across values of log(PPMR), so points with a larger biomass are prioritised/weighted more than those with a smaller biomass.

## Weighted by number of prey
```{r ave PPMR prey no., echo=TRUE}
ggplot(data = renamed_df, aes(x=lppmr)) + 
  labs(title = "Density plot of log(PPMR), weighted by number density of prey", 
       x="log(PPMR)", y="Number density of prey") +
  facet_wrap(~renamed_df$pred_species, scale="free_y") + 
  theme(strip.text = element_text(size = 5)) +
  geom_density(aes(weight = no._prey_per_stmch), colour="green")

#weight=no._prey_per_stmch means the points are 'weighted' by the number of prey per stomach
```

These plots are weighted by the number pf prey per stomach. This means that data points with a larger number of prey per stomach are prioritised/weighted more than those with a smaller number of prey per stomach.

By looking at the two differently weighted graphs, it is clear to see that the plots are 'shifted' by some amount (e.g. the Blue Whiting when weighted by prey biomass has a mean log(ppmr) of roughly 4.8, and when weighted by number of prey this mean becomes roughly 7.5).

# Introducing a mixed effects model

## Building up the model {.tabset}

### Basic Linear model

With $\log(\text{ppmr}) = m \times \log(\text{predator mass}) + c$

```{r linear model, echo=TRUE}
renamed_df %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    geom_line(size=1) + theme_classic()
```

### Null

Fixed effects: no fixed effects

Renamed effects: pred_species

```{r null model, echo=TRUE}
null <- lmer(lppmr ~ (1|pred_species), data = renamed_df, REML=FALSE)
#the 'null' model has no predictors (i.e. no linear effects)
#REML=FALSE means the model is made using 'maximum likelihood' (rather than Restricted Maximum Likelihood), which allows us to compare different models

renamed_df %>% 
    mutate(lppmr = fitted(null)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) +
    theme_classic() +
    geom_line(size=1) 
```

Mathematical representation:
$$
    \log(\text{ppmr})_{ij} = \beta_{0} + S_{0[j]} + \epsilon_{ij}
$$

This model has the following variables:
  * $i$ is the group
  * $j$ is the item
  * $\beta_{0}$ is the intercept term (grand mean)
  * $S_{0[j]}$ is the effect of the random term (pred_species)
  * $\epsilon_{ij}$ is the error term.


### First trial

Fixed effects: lpred_weight

Renamed effects: pred_species

```{r first, echo=TRUE}
one <- lmer(lppmr ~ lpred_weight + (1|pred_species), data = renamed_df, REML=FALSE)
#same slope for every effect (but varying intercept)

renamed_df %>% 
    mutate(lppmr= fitted(one)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    geom_line(size=1) 
```

### Second trial

Fixed effects: lprey_weight

Renamed effects: pred_species (random slope and fixed intercept; varies with respect to (w.r.t.) lprey_weight)

```{r second, echo=TRUE}
two <- lmer(lppmr ~ lpred_weight + (0+lpred_weight|pred_species), data = renamed_df, REML=FALSE)
#Random intercept and random slope (independent)

renamed_df %>% 
    mutate(lppmr = fitted(two)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    geom_line(size=1) 
```

### Third trial

Fixed effects: lprey_weight

Renamed effects: pred_species (random slope and random intercept; varies w.r.t lprey_weight)

```{r third, echo=TRUE}
three <- lmer(lppmr ~ lpred_weight + (1+lpred_weight|pred_species), data = renamed_df, REML=FALSE)
#Random intercept and random slope (correlated)

renamed_df %>% 
    mutate(lppmr = fitted(three)) %>% 
    ggplot(aes(x=lpred_weight, y=lppmr, group=pred_species, color=pred_species)) + 
    theme_classic() +
    geom_line(size=1) 
```

### Comparing the models

```{r forming models, echo=TRUE}
anova(null,one,two,three)
#comparing the four models

#(1+lprey_weight|pred_species)
#(1+pred_species|haul_id_short) --> doesn't compile?
#couldn't introduce (1+pred_species|haul_id_short) or (1+lprey_weight|haul_id_short)
```

## Trialing different models {.tabset}

Here, all the random effects are modelled with a randomly distributed slope and intercept.

### Trial a

Fixed effects: lpred_weight

Renamed effects: haul_id_short

```{r trial a, echo=TRUE}
a <- lmer(lppmr ~ lpred_weight + (1|haul_id_short), data = renamed_df, REML=FALSE)
a
hist(resid(a), border='red', col="transparent", main = paste("Histogram of residuals" ))
#Creates a histogram of the distribution of the residuals
print(VarCorr(a),comp="Variance")
#Only prints the variance estimates for the random effects
paste("AIC:", AIC(a))
#Prints the AIC value for this model
```

### Trial b

Fixed effects: lpred_weight

Renamed effects: haul_id_short, year

```{r trial b, echo=TRUE}
b <- lmer(lppmr ~ lpred_weight + (1|haul_id_short) + (1|year), data = renamed_df, REML=FALSE)
b
hist(resid(b), border='red', col="transparent", main = paste("Histogram of residuals" ))
print(VarCorr(b),comp="Variance")
paste("AIC:", AIC(b))
```

### Trial c

Fixed effects: lpred_weight

Renamed effects: haul_id_short, year, ices_rectangle

```{r trial c, echo=TRUE}
c <- lmer(lppmr ~ lpred_weight + (1|haul_id_short) + (1|year) + (1|ices_rectangle), data = renamed_df, REML=FALSE)
c
hist(resid(c), border='red', col="transparent", main = paste("Histogram of residuals" ))
print(VarCorr(c),comp="Variance")
paste("AIC:", AIC(c))
```

### Trial d

Fixed effects: lpred_weight

Renamed effects: haul_id_short, year, ices_rectangle, pred_species

```{r trial d, echo=TRUE}
d <- lmer(lppmr ~ lpred_weight + (1|haul_id_short) + (1|year) + (1|ices_rectangle) + (1|pred_species), data = renamed_df, REML=FALSE)
d
hist(resid(d), border='red', col="transparent", main = paste("Histogram of residuals" ))
print(VarCorr(d),comp="Variance")
paste("AIC:", AIC(d))
```

### Trial e

Fixed effects: lpred_weight, pred_species

Renamed effects: haul_id_short, year, ices_rectangle

```{r trial e, echo=TRUE}
e <- lmer(lppmr ~ lpred_weight + pred_species + (1|haul_id_short) + (1|year) + (1|ices_rectangle), data = renamed_df, REML=FALSE)
e
hist(resid(e), border='red', col="transparent", main = paste("Histogram of residuals" ))
print(VarCorr(e),comp="Variance")
paste("AIC:", AIC(e))
```

Mathematical representation
$$
  \log(\text{ppmr})_{ij} = \beta_{0} + \beta_{1} \log(\text{predator mass})_{j} + 
                \beta_{2} (\text{predator species})_{j} + A_{0[j]} + B_{0[j]} + 
                C_{0[j]} + \epsilon_{ij}
$$

This model has the following variables:

Variable name |  Meaning            | Value       |  Where to find
------------- | -----------         | -------     | -------------
$i$           | the group           | -           | -
$j$           | the item            | -           | -
$\beta_{0}$   | the intercept term  |  3.304181   | fixed effects -> intercept -> estimate
$\beta_{1}$   | the fixed effect (slope) for $\log(\text{prey weight})$ | -0.758358   | fixed effects -> lprey_weight -> estimat
$\beta_{2}$   | the fixed effect for $\text{predator species}$| (?)  | -
$A_{0[j]}$    | the random intercept for item $j$ (dependent on the haul_id_short term) | - | -
$\omega_{A[00]}$ |  s.d. for A, haul_id_short | 1.6472 |random effects -> groups -> ices_rectangle -> std. dev.
$B_{0[j]}$    | random intercept for dep. on the year term | -           | -
$\omega_{B[00]}$ | [s.d. for B, year] |  1.4235   | -
$\omega_{C[00]}$ | [s.d. for C, ices_rectangle] | 0.4331    | -
$C_{0[j]}$    | dep. on the ices_rectangle term | -             | -
$\epsilon_{ij}$ | the residual/error term for each individual item | 1.0729 | random effects -> groups -> residual -> std. dev.
 
Note: 

  * $A_{0[j]}$ is normally distributed with a mean of 0 and a standard deviation $\omega_{00}$ (i.e. $I_{0[j]} \sim \mathcal{N} (0,\omega_{A[00]}^2)$)
  * Value of $\beta_{2} = $ should be individual for each pred species??


## Outputs

Outputs:

  * standard deviation for the random effects and residuals (want low values)
  * no. of observations
  * fixed effect, i.e. output of a linear model
  * frequency plot of the residuals (want clustered around resid=0)

Variance of the groups decreases as other random effects are added to the models.
But, the error term (standard error) roughly increases as more random effects are added to the model.

## Adding weighting to the models

```{r weighted mixed effects models, echo=TRUE}
#Do we need weighting? Bc it's not a density plot

#trial_df <- data.frame(lppmr = 10:5,                
#                 prey_weight_g = "x",
#                 lprey_weight = letters[1:6],
#                 no._prey_per_stmch = "y")

#renamed_df %>% 
#    mutate(lppmr = fitted(d)) %>% 
#      ggplot(aes(x=lppmr)) + 
#      labs(title = "Density plot of log(PPMR), weighted by biomass density of prey", 
#       x="log(PPMR)", y="Biomass density of prey") +
#      facet_wrap(~renamed_df$pred_species, scale="free_y") + 
#      theme(strip.text = element_text(size = 5)) +
#      geom_density(aes(weight = prey_weight_g), colour="red")
          
#weight_mixed <- lmer(lppmr ~ lpred_weight, data = herringDF, REML=FALSE)

#weighting observations by prey_weight_g
#two <- update(weight_mixed, weights = prey_weight_g)
#summary(two)

#weighting observations by no._prey_per_stmch
#three <- update(weight_mixed, weights = no._prey_per_stmch)
#summary(three)

#anova(two,three)
```

# Citations

```{r citations, echo=TRUE}
#citation()

#devtools::session_info()
```